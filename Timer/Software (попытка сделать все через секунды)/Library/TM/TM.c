//***************************************************************************
//  Author(s):    Владимир Иванишин (http://de.my1.ru)
//  Target(s):    TaskManager
//  Compiler:     GCC
//  Description:  Библиотека диспетчера задач с таймерной службой
//  Data:         04.04.17
//***************************************************************************
// Описания файла: в данном файле находятся все функции работы диспетчера.
//***************************************************************************
#include "TM.h"
//***************************************************************************



//***************************************************************************
// Инициализация диспетчера задач
//***************************************************************************
inline void RTOS_Init(void)													
{
	// Инициализируем диспетчер задач
	__TM_Start = 0;															// Обнуляем указатель начала очереди
	__TM_End = 0;															// Обнуляем указатель конца очереди
	__TM_TaskCnt = 0;														// Сбрасываем счетчик задач
	
	// Инициализируем таймерную службу
	for (uint8_t i = 0; i < __TS_TimerQueueSize; i++)
	{
		__TS_TimerTaskQueue[i].Task = Idle;									// Заполняем структуру затычками
		__TS_TimerTaskQueue[i].Time = 0;									// Обнуляем временные интервалы
	}
}



//***************************************************************************
// Запуск диспетчера задач
//***************************************************************************
inline void RTOS_Run(void)
{
	cli();																	// Запрещаем прерывания
																			// Настраиваем таймер. Я взял TIMER0, потому как он нифига не могет.
																			// Ты же можешь взять что-нибудь помощнее, хоть 16-битный TIMER1.
	TCCR0 &= ~((1<<CS02)|(1<<CS02)|(1<<CS02));								// Очищаем биты предделителя.
	TCCR0 |= ((1<<CS01)|(1<<CS00));											// И ставим предделитель 64.
	TCNT0 = __TS_Timer0_TCNTDefault;										// Инициализируем значение счетчика
	TIMSK |= (1<<TOIE0);													// и врубаем прерывание по переполнению.
	
	
	sei();																	// Врубаем глобальные прерывания и валим.
}



//***************************************************************************
// Отправка задачи в очередь диспетчера задач
//***************************************************************************
void SendTask(TPTR Task)
{
	uint8_t noint = 0;
	if (SREG&(1<<SREG_I))													// Если мы не находимся в прерывании...
	{
		cli();																// ...то запрещаем прерывания
		noint = 1;															// и взводим флажок, что мы не в прерывании, и надо разрешить их по выходу.
	}
	
	if (__TM_TaskCnt < __TM_TaskQueueSize)									// Если в очереди есть свободное место...
	{
		__TM_TaskQueue[__TM_End] = Task;									// ...то пишем в него нашу задачу
		__TM_End++;															// и смещаем наш указатель на конец очереди.
		if (__TM_End == __TM_TaskQueueSize)									// Если дошли до конца массива, 
			__TM_End = 0;													// то сбрасываем указатель.
		__TM_TaskCnt++;
		
		if (noint) sei();													// Если мы не в прерывании - разрешаем прерывания.
	}
	else																	// ...иначе, если пустого места нет...
	{
		if (noint) sei();													// ...разрешаем прерывания, если мы не в прерывании.
		return;																// И выходим. Можно возвращать код ошибки какой-нибудь. 
																			// Но мне было лень это писать... :)
	}
}



//***************************************************************************
// Отправка задачи в очередь таймерной службы
//***************************************************************************
void SendTimerTask(TPTR Task, uint16_t Time)
{
	uint8_t i = 0;															// Инициализируем переменные
	uint8_t noint = 0;
	if (SREG&(1<<SREG_I))													// Если мы не находимся в прерывании...
	{
		cli();																// ...то запрещаем прерывания
		noint = 1;															// и взводим флажок, что мы не в прерывании, и надо разрешить их по выходу.
	}	
	
	while (__TS_TimerTaskQueue[i].Task != Idle)								// Прочесываем очередь на наличие свободного места,
	{
		i++;																// по очереди проверяя каждую ячейку.
		if (i == __TS_TimerQueueSize)										// Если дошли до конца...
		{
			if (noint) sei();												// ...разрешаем прерывания, если мы не в прерывании.
			return;															// И выходим. Можно возвращать код ошибки какой-нибудь.
																			// Но мне было лень это писать... :)
		}
	}
	
	if (noint) sei();														// Если мы не в прерывании - разрешаем прерывания.
																			// Если нашли свободное место -
	__TS_TimerTaskQueue[i].Task = Task;										// пишем нашу задачу
	__TS_TimerTaskQueue[i].Time = Time;										// и время, через которое ее нужно будет запустить.
}



//***************************************************************************
// Обновление тайминга задачи
//***************************************************************************
void UpdateTimerTask(TPTR Task, uint16_t Time)
{
	uint8_t i = 0;
	while (__TS_TimerTaskQueue[i].Task != Task)								// Прочесываем очередь задач, и как только нашли нашу задачку
		i++;
	__TS_TimerTaskQueue[i].Time = Time;
}
//***************************************************************************
// Удаление задачи из таймерной службы
//***************************************************************************
uint16_t RemoveTask (TPTR Task)
{
	uint8_t i = 0;
	while ((i < __TS_TimerQueueSize) && (__TS_TimerTaskQueue[i].Task != Task))		
		i++;																// Прочесываем очередь
																			// Если натыкаемся на нашу задачу...
	__TS_TimerTaskQueue[i].Task = Idle;										// ...удаляем ее нафиг, записав затычку на ее место
	
	return __TS_TimerTaskQueue[i].Time;										// И возвращаем время, через которое задача могла выполниться
}


//***************************************************************************
// Запуск диспетчера задач
//***************************************************************************
inline void TaskManager(void)
{
	TPTR Task;																// Инициализируем переменные
	
	cli();																	// Запрещаем прерывания
	
	if (__TM_TaskCnt != 0)													// Если есть задачи на обработку...
	{
		//PORTB |= (1<<3);													// Для оценки загруженности диспетчера,
																			// при обработке задач устанавливаем пин порта в 1.
																			// А когда все задачи выполнены - сбрасываем в 0.
																			
		Task = __TM_TaskQueue[__TM_Start];									// ... то берем ее из очереди
		__TM_Start++;														// и смещаем указатель начала очереди.
		if (__TM_Start == __TM_TaskQueueSize)								// Если дошли до конца массива,
			__TM_Start = 0;													// то сбрасываем указатель.
		__TM_TaskCnt--;
		sei();																// Разрешаем прерывания.
		
		(Task)();															// И валим выполнять нашу задачу.
	}
	/*else
	{
		PORTB &= ~(1<<3);													// Для оценки загруженности диспетчера,
	}*/																		// при обработке задач устанавливаем пин порта в 1.
																			// А когда все задачи выполнены - сбрасываем в 0.
	
	sei();																	// Разрешаем прерывания.
}



//***************************************************************************
// Запуск таймерной службы
//***************************************************************************
inline void TimerService(void)
{
	for (uint8_t i = 0; i < __TS_TimerQueueSize; i++)						// Прочесываем очередь
	{
		if (__TS_TimerTaskQueue[i].Task == Idle) continue;					// Если натыкаемся на затычку - переходим к следующей ячейке.
		if (__TS_TimerTaskQueue[i].Time != 0)								// Если натыкаемся на адекватную задачу и ее время еще не истекло...
		{
			__TS_TimerTaskQueue[i].Time--;									// ...декрементируем ее временную задержку
		}
		else																// ...иначе, если пришло время выполнять задачу...
		{
			SendTask(__TS_TimerTaskQueue[i].Task);							// ...пхаем эту задачу в диспетчер задач
			__TS_TimerTaskQueue[i].Task = Idle;								// и пишем на ее место затычку.
		}
	}
}



//***************************************************************************
// Прерывание системного таймера
//***************************************************************************
ISR(__TS_ISR)
{
	TCNT0 = __TS_Timer0_TCNTDefault;										// Сбрасываем значение счетчика
	
	TimerService();															// Вызываем таймерную службу
}



//***************************************************************************
// Пустая процедура - простой ядра
//***************************************************************************
inline void Idle(void)
{

}