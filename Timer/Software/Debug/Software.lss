
Software.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000dba  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000074  00800060  00000dba  00000e6e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000006d  008000d4  008000d4  00000ee2  2**0
                  ALLOC
  3 .eeprom       0000000f  00810000  00810000  00000ee2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      00000030  00000000  00000000  00000ef1  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000f24  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000158  00000000  00000000  00000f60  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000017d2  00000000  00000000  000010b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000acd  00000000  00000000  0000288a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  00003357  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000003d4  00000000  00000000  00004104  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000550  00000000  00000000  000044d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000d19  00000000  00000000  00004a28  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000128  00000000  00000000  00005741  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	00 c2       	rjmp	.+1024   	; 0x402 <__ctors_end>
   2:	1a c2       	rjmp	.+1076   	; 0x438 <__bad_interrupt>
   4:	19 c2       	rjmp	.+1074   	; 0x438 <__bad_interrupt>
   6:	18 c2       	rjmp	.+1072   	; 0x438 <__bad_interrupt>
   8:	17 c2       	rjmp	.+1070   	; 0x438 <__bad_interrupt>
   a:	16 c2       	rjmp	.+1068   	; 0x438 <__bad_interrupt>
   c:	15 c2       	rjmp	.+1066   	; 0x438 <__bad_interrupt>
   e:	14 c2       	rjmp	.+1064   	; 0x438 <__bad_interrupt>
  10:	13 c2       	rjmp	.+1062   	; 0x438 <__bad_interrupt>
  12:	b8 c4       	rjmp	.+2416   	; 0x984 <__vector_9>
  14:	11 c2       	rjmp	.+1058   	; 0x438 <__bad_interrupt>
  16:	10 c2       	rjmp	.+1056   	; 0x438 <__bad_interrupt>
  18:	0f c2       	rjmp	.+1054   	; 0x438 <__bad_interrupt>
  1a:	0e c2       	rjmp	.+1052   	; 0x438 <__bad_interrupt>
  1c:	0d c2       	rjmp	.+1050   	; 0x438 <__bad_interrupt>
  1e:	0c c2       	rjmp	.+1048   	; 0x438 <__bad_interrupt>
  20:	0b c2       	rjmp	.+1046   	; 0x438 <__bad_interrupt>
  22:	0a c2       	rjmp	.+1044   	; 0x438 <__bad_interrupt>
  24:	09 c2       	rjmp	.+1042   	; 0x438 <__bad_interrupt>

00000026 <LargeNum>:
	...
  36:	00 00 00 30 30 00 00 00 00 00 00 03 03 00 00 00     ...00...........
  46:	00 fc 03 c3 c3 33 fc 00 00 0f 33 30 30 30 0f 00     .....3....3000..
  56:	00 00 00 0c ff 00 00 00 00 00 00 30 3f 30 00 00     ...........0?0..
  66:	00 0c 03 c3 c3 c3 3c 00 00 3c 33 30 30 30 30 00     ......<..<30000.
  76:	00 03 03 c3 c3 f3 0f 00 00 0c 30 30 30 30 0f 00     ..........0000..
  86:	00 00 c0 30 0c ff 00 00 00 03 03 03 03 3f 03 00     ...0.........?..
  96:	00 3f 33 33 33 33 c3 00 00 0c 30 30 30 30 0f 00     .?3333....0000..
  a6:	00 f0 cc c3 c3 c3 03 00 00 0f 30 30 30 30 0f 00     ..........0000..
  b6:	00 03 03 03 c3 33 0f 00 00 00 00 3f 00 00 00 00     .....3.....?....
  c6:	00 3c c3 c3 c3 c3 3c 00 00 0f 30 30 30 30 0f 00     .<....<...0000..
  d6:	00 3c c3 c3 c3 c3 fc 00 00 30 30 30 30 0c 03 00     .<.......0000...

000000e6 <SmallFont>:
  e6:	00 00 00 00 00 00 00 5f 00 00 00 07 00 07 00 14     ......._........
  f6:	7f 14 7f 14 24 2a 7f 2a 12 62 64 08 13 23 36 49     ....$*.*.bd..#6I
 106:	55 22 50 00 05 03 00 00 00 1c 22 41 00 00 41 22     U"P......."A..A"
 116:	1c 00 14 08 3e 08 14 08 08 3e 08 08 00 00 a0 60     ....>....>.....`
 126:	00 08 08 08 08 08 00 60 60 00 00 20 10 08 04 02     .......``.. ....
 136:	3e 51 49 45 3e 00 42 7f 40 00 42 61 51 49 46 21     >QIE>.B.@.BaQIF!
 146:	41 45 4b 31 18 14 12 7f 10 27 45 45 45 39 3c 4a     AEK1.....'EEE9<J
 156:	49 49 30 01 71 09 05 03 36 49 49 49 36 06 49 49     II0.q...6III6.II
 166:	29 1e 00 36 36 00 00 00 56 36 00 00 08 14 22 41     )..66...V6...."A
 176:	00 14 14 14 14 14 00 41 22 14 08 02 01 51 09 06     .......A"....Q..
 186:	32 49 59 51 3e 7c 12 11 12 7c 7f 49 49 49 36 3e     2IYQ>|...|.III6>
 196:	41 41 41 22 7f 41 41 22 1c 7f 49 49 49 41 7f 09     AAA".AA"..IIIA..
 1a6:	09 09 01 3e 41 49 49 7a 7f 08 08 08 7f 00 41 7f     ...>AIIz......A.
 1b6:	41 00 20 40 41 3f 01 7f 08 14 22 41 7f 40 40 40     A. @A?...."A.@@@
 1c6:	40 7f 02 0c 02 7f 7f 04 08 10 7f 3e 41 41 41 3e     @..........>AAA>
 1d6:	7f 09 09 09 06 3e 41 51 21 5e 7f 09 19 29 46 46     .....>AQ!^...)FF
 1e6:	49 49 49 31 01 01 7f 01 01 3f 40 40 40 3f 1f 20     III1.....?@@@?. 
 1f6:	40 20 1f 3f 40 38 40 3f 63 14 08 14 63 07 08 70     @ .?@8@?c...c..p
 206:	08 07 61 51 49 45 43 00 7f 41 41 00 02 04 08 10     ..aQIEC..AA.....
 216:	20 00 41 41 7f 00 04 02 01 02 04 40 40 40 40 40      .AA.......@@@@@
 226:	00 01 02 04 00 20 54 54 54 78 7f 48 44 44 38 38     ..... TTTx.HDD88
 236:	44 44 44 20 38 44 44 48 7f 38 54 54 54 18 08 7e     DDD 8DDH.8TTT..~
 246:	09 01 02 18 a4 a4 a4 7c 7f 08 04 04 78 00 44 7d     .......|....x.D}
 256:	40 00 40 80 84 7d 00 7f 10 28 44 00 00 41 7f 40     @.@..}...(D..A.@
 266:	00 7c 04 18 04 78 7c 08 04 04 78 38 44 44 44 38     .|...x|...x8DDD8
 276:	fc 24 24 24 18 18 24 24 18 fc 7c 08 04 04 08 48     .$$$..$$..|....H
 286:	54 54 54 20 04 3f 44 40 20 3c 40 40 20 7c 1c 20     TTT .?D@ <@@ |. 
 296:	40 20 1c 3c 40 30 40 3c 44 28 10 28 44 1c a0 a0     @ .<@0@<D(.(D...
 2a6:	a0 7c 44 64 54 4c 44 00 08 36 41 00 00 00 7f 00     .|DdTLD..6A.....
 2b6:	00 00 41 36 08 00 08 04 08 10 08 7e 11 11 11 7e     ..A6.......~...~
 2c6:	7f 49 49 49 31 7f 49 49 49 36 7f 01 01 01 01 c0     .III1.III6......
 2d6:	7f 41 7f c0 7f 49 49 49 41 73 0c 7f 0c 73 41 49     .A...IIIAs...sAI
 2e6:	49 36 00 7f 10 0c 02 7f 7f 20 19 04 7f 7f 08 14     I6....... ......
 2f6:	22 41 40 3e 01 01 7f 7f 02 0c 02 7f 7f 08 08 08     "A@>............
 306:	7f 3e 41 41 41 3e 7f 01 01 01 7f 7f 09 09 09 06     .>AAA>..........
 316:	3e 41 41 41 22 01 01 7f 01 01 43 4c 30 0c 03 0e     >AAA".....CL0...
 326:	11 7f 11 0e 63 14 08 14 63 7f 40 40 7f c0 07 08     ....c...c.@@....
 336:	08 7f 00 7f 40 7f 40 7f 7f 40 7f 40 ff 01 7f 48     ....@.@..@.@...H
 346:	48 30 7f 48 30 00 7f 7f 48 48 30 00 49 49 49 3e     H0.H0...HH0.III>
 356:	00 7f 08 3e 41 3e 46 29 19 09 7f 20 54 54 54 78     ...>A>F)... TTTx
 366:	3c 4a 4b 49 30 7c 54 54 28 00 7c 04 04 04 00 c0     <JKI0|TT(.|.....
 376:	7c 44 7c c0 38 54 54 54 18 44 28 7c 28 44 44 54     |D|.8TTT.D(|(DDT
 386:	54 28 00 7c 20 10 08 7c 7c 20 12 08 7c 7c 10 28     T(.| ..|| ..||.(
 396:	44 00 40 3c 04 04 7c 7c 08 10 08 7c 7c 10 10 7c     D.@<..||...||..|
 3a6:	00 38 44 44 44 38 7c 04 04 7c 00 7c 14 14 14 08     .8DDD8|..|.|....
 3b6:	38 44 44 44 20 04 04 7c 04 04 84 98 60 18 04 18     8DDD ..|....`...
 3c6:	24 fc 24 18 44 28 10 28 44 7c 40 40 7c c0 0c 10     $.$.D(.(D|@@|...
 3d6:	10 7c 00 7c 40 7c 40 7c 7c 40 7c 40 fc 04 7c 50     .|.|@|@||@|@..|P
 3e6:	50 20 7c 50 70 00 7c 7c 50 50 20 00 54 54 54 38     P |Pp.||PP .TTT8
 3f6:	00 7c 10 38 44 38 48 34 14 7c 00 00                 .|.8D8H4.|..

00000402 <__ctors_end>:
 402:	11 24       	eor	r1, r1
 404:	1f be       	out	0x3f, r1	; 63
 406:	cf e5       	ldi	r28, 0x5F	; 95
 408:	d4 e0       	ldi	r29, 0x04	; 4
 40a:	de bf       	out	0x3e, r29	; 62
 40c:	cd bf       	out	0x3d, r28	; 61

0000040e <__do_copy_data>:
 40e:	10 e0       	ldi	r17, 0x00	; 0
 410:	a0 e6       	ldi	r26, 0x60	; 96
 412:	b0 e0       	ldi	r27, 0x00	; 0
 414:	ea eb       	ldi	r30, 0xBA	; 186
 416:	fd e0       	ldi	r31, 0x0D	; 13
 418:	02 c0       	rjmp	.+4      	; 0x41e <__do_copy_data+0x10>
 41a:	05 90       	lpm	r0, Z+
 41c:	0d 92       	st	X+, r0
 41e:	a4 3d       	cpi	r26, 0xD4	; 212
 420:	b1 07       	cpc	r27, r17
 422:	d9 f7       	brne	.-10     	; 0x41a <__do_copy_data+0xc>

00000424 <__do_clear_bss>:
 424:	21 e0       	ldi	r18, 0x01	; 1
 426:	a4 ed       	ldi	r26, 0xD4	; 212
 428:	b0 e0       	ldi	r27, 0x00	; 0
 42a:	01 c0       	rjmp	.+2      	; 0x42e <.do_clear_bss_start>

0000042c <.do_clear_bss_loop>:
 42c:	1d 92       	st	X+, r1

0000042e <.do_clear_bss_start>:
 42e:	a1 34       	cpi	r26, 0x41	; 65
 430:	b2 07       	cpc	r27, r18
 432:	e1 f7       	brne	.-8      	; 0x42c <.do_clear_bss_loop>
 434:	d5 d3       	rcall	.+1962   	; 0xbe0 <main>
 436:	bf c4       	rjmp	.+2430   	; 0xdb6 <_exit>

00000438 <__bad_interrupt>:
 438:	e3 cd       	rjmp	.-1082   	; 0x0 <__vectors>

0000043a <LCD5110_SendByte>:
//***************************************************************************
void LCD5110_SendByte(unsigned char data, unsigned char command)
{
	unsigned char i;		
	
	__LCD5110_Port &= ~(1<<__LCD5110_CE);				// Активируем контроллер дисплея
 43a:	93 98       	cbi	0x12, 3	; 18
	
	if (command == 0)									// Если отправляем комманду,...
 43c:	61 11       	cpse	r22, r1
 43e:	02 c0       	rjmp	.+4      	; 0x444 <LCD5110_SendByte+0xa>
		__LCD5110_Port &= ~(1<<__LCD5110_DC);			// ...то сбрасываем вывод комманда/данные
 440:	92 98       	cbi	0x12, 2	; 18
 442:	0e c0       	rjmp	.+28     	; 0x460 <__stack+0x1>
	else
		__LCD5110_Port |= (1<<__LCD5110_DC);			// Иначе устанавливаем, показывая то, что мы передаем данные
 444:	92 9a       	sbi	0x12, 2	; 18
 446:	0c c0       	rjmp	.+24     	; 0x460 <__stack+0x1>

	for(i = 0; i < 8; i++)								// По очереди проталкиваем байт. Бит за битом
	{
		if(data & 0x80)
 448:	88 23       	and	r24, r24
 44a:	14 f4       	brge	.+4      	; 0x450 <LCD5110_SendByte+0x16>
			__LCD5110_Port |= (1<<__LCD5110_DIN);
 44c:	91 9a       	sbi	0x12, 1	; 18
 44e:	01 c0       	rjmp	.+2      	; 0x452 <LCD5110_SendByte+0x18>
		else
			__LCD5110_Port &= ~(1<<__LCD5110_DIN);
 450:	91 98       	cbi	0x12, 1	; 18
		
		__LCD5110_Port &= ~(1<<__LCD5110_CLK);
 452:	90 98       	cbi	0x12, 0	; 18
		data = data << 1;
 454:	88 0f       	add	r24, r24
		__LCD5110_Port |= (1<<__LCD5110_CLK);
 456:	90 9a       	sbi	0x12, 0	; 18
 458:	91 50       	subi	r25, 0x01	; 1
	if (command == 0)									// Если отправляем комманду,...
		__LCD5110_Port &= ~(1<<__LCD5110_DC);			// ...то сбрасываем вывод комманда/данные
	else
		__LCD5110_Port |= (1<<__LCD5110_DC);			// Иначе устанавливаем, показывая то, что мы передаем данные

	for(i = 0; i < 8; i++)								// По очереди проталкиваем байт. Бит за битом
 45a:	b1 f7       	brne	.-20     	; 0x448 <LCD5110_SendByte+0xe>
		
		__LCD5110_Port &= ~(1<<__LCD5110_CLK);
		data = data << 1;
		__LCD5110_Port |= (1<<__LCD5110_CLK);
	}
	__LCD5110_Port |= (1<<__LCD5110_CE);				// В конце отключаем контроллер от шины
 45c:	93 9a       	sbi	0x12, 3	; 18
 45e:	08 95       	ret

//***************************************************************************
// Отправка байта на дисплей
//***************************************************************************
void LCD5110_SendByte(unsigned char data, unsigned char command)
{
 460:	98 e0       	ldi	r25, 0x08	; 8
 462:	f2 cf       	rjmp	.-28     	; 0x448 <LCD5110_SendByte+0xe>

00000464 <LCD5110_Clear>:

//***************************************************************************
// Очистка дисплея
//***************************************************************************
void LCD5110_Clear(void)
{
 464:	cf 93       	push	r28
 466:	df 93       	push	r29
	unsigned int i;

	LCD5110_SendByte(0x40, 0);							// Переходим в первую строку							
 468:	60 e0       	ldi	r22, 0x00	; 0
 46a:	80 e4       	ldi	r24, 0x40	; 64
 46c:	e6 df       	rcall	.-52     	; 0x43a <LCD5110_SendByte>
	LCD5110_SendByte(0x80, 0);							// В первый столбец
 46e:	60 e0       	ldi	r22, 0x00	; 0
 470:	80 e8       	ldi	r24, 0x80	; 128
 472:	e3 df       	rcall	.-58     	; 0x43a <LCD5110_SendByte>
 474:	c8 ef       	ldi	r28, 0xF8	; 248
 476:	d1 e0       	ldi	r29, 0x01	; 1

	for (i=0; i<504; i++)
		LCD5110_SendByte(0, 1);							// И пхаем все это дело внутрь
 478:	61 e0       	ldi	r22, 0x01	; 1
 47a:	80 e0       	ldi	r24, 0x00	; 0
 47c:	de df       	rcall	.-68     	; 0x43a <LCD5110_SendByte>
 47e:	21 97       	sbiw	r28, 0x01	; 1
	unsigned int i;

	LCD5110_SendByte(0x40, 0);							// Переходим в первую строку							
	LCD5110_SendByte(0x80, 0);							// В первый столбец

	for (i=0; i<504; i++)
 480:	d9 f7       	brne	.-10     	; 0x478 <LCD5110_Clear+0x14>
		LCD5110_SendByte(0, 1);							// И пхаем все это дело внутрь
}
 482:	df 91       	pop	r29
 484:	cf 91       	pop	r28
 486:	08 95       	ret

00000488 <LCD5110_Init>:
//***************************************************************************
// Инициализация дисплея
//***************************************************************************
void LCD5110_Init(void)
{
	__LCD5110_DDR |= (1<<__LCD5110_R)|(1<<__LCD5110_CE)|(1<<__LCD5110_DC)|(1<<__LCD5110_DIN)|(1<<__LCD5110_CLK);
 488:	81 b3       	in	r24, 0x11	; 17
 48a:	8f 61       	ori	r24, 0x1F	; 31
 48c:	81 bb       	out	0x11, r24	; 17

	__LCD5110_Port &= ~(1<<__LCD5110_R);				// Сброс дисплея
 48e:	94 98       	cbi	0x12, 4	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 490:	82 e0       	ldi	r24, 0x02	; 2
 492:	8a 95       	dec	r24
 494:	f1 f7       	brne	.-4      	; 0x492 <LCD5110_Init+0xa>
 496:	00 c0       	rjmp	.+0      	; 0x498 <LCD5110_Init+0x10>
	_delay_us(1);
	__LCD5110_Port |= (1<<__LCD5110_R);
 498:	94 9a       	sbi	0x12, 4	; 18
	
	__LCD5110_Port &= ~(1<<__LCD5110_CE);				// Включение дисплея
 49a:	93 98       	cbi	0x12, 3	; 18
 49c:	82 e0       	ldi	r24, 0x02	; 2
 49e:	8a 95       	dec	r24
 4a0:	f1 f7       	brne	.-4      	; 0x49e <LCD5110_Init+0x16>
 4a2:	00 c0       	rjmp	.+0      	; 0x4a4 <LCD5110_Init+0x1c>
	_delay_us(1);
	__LCD5110_Port |= (1<<__LCD5110_CE);
 4a4:	93 9a       	sbi	0x12, 3	; 18
 4a6:	82 e0       	ldi	r24, 0x02	; 2
 4a8:	8a 95       	dec	r24
 4aa:	f1 f7       	brne	.-4      	; 0x4a8 <LCD5110_Init+0x20>
 4ac:	00 c0       	rjmp	.+0      	; 0x4ae <LCD5110_Init+0x26>
	_delay_us(1);
	
	LCD5110_SendByte(0b00100001, 0);					// Адресация: горизонтальная
 4ae:	60 e0       	ldi	r22, 0x00	; 0
 4b0:	81 e2       	ldi	r24, 0x21	; 33
 4b2:	c3 df       	rcall	.-122    	; 0x43a <LCD5110_SendByte>
														// Тип функций: расширенный 
	LCD5110_SendByte(0b11001000, 0);					// Напряжение на генераторе ПН 7.38 вольт 
 4b4:	60 e0       	ldi	r22, 0x00	; 0
 4b6:	88 ec       	ldi	r24, 0xC8	; 200
 4b8:	c0 df       	rcall	.-128    	; 0x43a <LCD5110_SendByte>
	LCD5110_SendByte(0b00000110, 0);					// Режим температурной коррекции 
 4ba:	60 e0       	ldi	r22, 0x00	; 0
 4bc:	86 e0       	ldi	r24, 0x06	; 6
 4be:	bd df       	rcall	.-134    	; 0x43a <LCD5110_SendByte>
	LCD5110_SendByte(0b00010011, 0);					// Напряжение смещения 
 4c0:	60 e0       	ldi	r22, 0x00	; 0
 4c2:	83 e1       	ldi	r24, 0x13	; 19
 4c4:	ba df       	rcall	.-140    	; 0x43a <LCD5110_SendByte>
	LCD5110_SendByte(0b00100000, 0);					// Тип функций: обычный 
 4c6:	60 e0       	ldi	r22, 0x00	; 0
 4c8:	80 e2       	ldi	r24, 0x20	; 32
 4ca:	b7 df       	rcall	.-146    	; 0x43a <LCD5110_SendByte>
	LCD5110_Clear();
 4cc:	cb df       	rcall	.-106    	; 0x464 <LCD5110_Clear>
	LCD5110_SendByte(0b00001100, 0);					// Инверсия: отключена
 4ce:	60 e0       	ldi	r22, 0x00	; 0
 4d0:	8c e0       	ldi	r24, 0x0C	; 12
 4d2:	b3 df       	rcall	.-154    	; 0x43a <LCD5110_SendByte>
														// Вывод изображения: включен 
	__LCD5110_Port &= ~(1<<__LCD5110_CE);
 4d4:	93 98       	cbi	0x12, 3	; 18
 4d6:	08 95       	ret

000004d8 <LCD5110_SetXY>:

//***************************************************************************
// Установка начала координат дисплея
//***************************************************************************
void LCD5110_SetXY(unsigned char X, unsigned char Y)
{
 4d8:	cf 93       	push	r28
 4da:	c8 2f       	mov	r28, r24
 4dc:	86 2f       	mov	r24, r22
	 LCD5110_SendByte(0x40 | Y, 0);						// Строка
 4de:	60 e0       	ldi	r22, 0x00	; 0
 4e0:	80 64       	ori	r24, 0x40	; 64
 4e2:	ab df       	rcall	.-170    	; 0x43a <LCD5110_SendByte>
	 LCD5110_SendByte(0x80 | X, 0);						// Столбец
 4e4:	60 e0       	ldi	r22, 0x00	; 0
 4e6:	8c 2f       	mov	r24, r28
 4e8:	80 68       	ori	r24, 0x80	; 128
 4ea:	a7 df       	rcall	.-178    	; 0x43a <LCD5110_SendByte>
}
 4ec:	cf 91       	pop	r28
 4ee:	08 95       	ret

000004f0 <LCD5110_Putc>:

//***************************************************************************
// Вывод символа на дисплей
//***************************************************************************
void LCD5110_Putc(unsigned char c)
{
 4f0:	0f 93       	push	r16
 4f2:	1f 93       	push	r17
 4f4:	cf 93       	push	r28
 4f6:	df 93       	push	r29
	unsigned char i;
	
	if (c >= 'А')
 4f8:	80 3c       	cpi	r24, 0xC0	; 192
 4fa:	10 f0       	brcs	.+4      	; 0x500 <LCD5110_Putc+0x10>
		c -= 97;
 4fc:	81 56       	subi	r24, 0x61	; 97
 4fe:	01 c0       	rjmp	.+2      	; 0x502 <LCD5110_Putc+0x12>
	else
		c -= 32;
 500:	80 52       	subi	r24, 0x20	; 32
 502:	90 e0       	ldi	r25, 0x00	; 0
 504:	8c 01       	movw	r16, r24
 506:	00 0f       	add	r16, r16
 508:	11 1f       	adc	r17, r17
 50a:	00 0f       	add	r16, r16
 50c:	11 1f       	adc	r17, r17
 50e:	08 0f       	add	r16, r24
 510:	19 1f       	adc	r17, r25

//***************************************************************************
// Вывод символа на дисплей
//***************************************************************************
void LCD5110_Putc(unsigned char c)
{
 512:	c0 e0       	ldi	r28, 0x00	; 0
 514:	d0 e0       	ldi	r29, 0x00	; 0
 516:	fe 01       	movw	r30, r28
 518:	e0 0f       	add	r30, r16
 51a:	f1 1f       	adc	r31, r17
 51c:	ea 51       	subi	r30, 0x1A	; 26
 51e:	ff 4f       	sbci	r31, 0xFF	; 255
		c -= 97;
	else
		c -= 32;
	
	for (i = 0; i < 5; i++)
		LCD5110_SendByte(pgm_read_byte(SmallFont[c]+i), 1);
 520:	84 91       	lpm	r24, Z
 522:	61 e0       	ldi	r22, 0x01	; 1
 524:	8a df       	rcall	.-236    	; 0x43a <LCD5110_SendByte>
 526:	21 96       	adiw	r28, 0x01	; 1
	if (c >= 'А')
		c -= 97;
	else
		c -= 32;
	
	for (i = 0; i < 5; i++)
 528:	c5 30       	cpi	r28, 0x05	; 5
 52a:	d1 05       	cpc	r29, r1
 52c:	a1 f7       	brne	.-24     	; 0x516 <LCD5110_Putc+0x26>
		LCD5110_SendByte(pgm_read_byte(SmallFont[c]+i), 1);
	LCD5110_SendByte(0, 1);
 52e:	61 e0       	ldi	r22, 0x01	; 1
 530:	80 e0       	ldi	r24, 0x00	; 0
 532:	83 df       	rcall	.-250    	; 0x43a <LCD5110_SendByte>
}
 534:	df 91       	pop	r29
 536:	cf 91       	pop	r28
 538:	1f 91       	pop	r17
 53a:	0f 91       	pop	r16
 53c:	08 95       	ret

0000053e <LCD5110_Prints>:

//***************************************************************************
// Вывод строки на дисплей
//***************************************************************************
void LCD5110_Prints(char *s, unsigned char X, unsigned char Y)
{
 53e:	cf 93       	push	r28
 540:	df 93       	push	r29
 542:	ec 01       	movw	r28, r24
 544:	86 2f       	mov	r24, r22
	LCD5110_SetXY(X,Y);
 546:	64 2f       	mov	r22, r20
 548:	c7 df       	rcall	.-114    	; 0x4d8 <LCD5110_SetXY>
	while (*s)
 54a:	88 81       	ld	r24, Y
 54c:	88 23       	and	r24, r24
 54e:	29 f0       	breq	.+10     	; 0x55a <LCD5110_Prints+0x1c>
 550:	21 96       	adiw	r28, 0x01	; 1
	{
		LCD5110_Putc(*s);
 552:	ce df       	rcall	.-100    	; 0x4f0 <LCD5110_Putc>
// Вывод строки на дисплей
//***************************************************************************
void LCD5110_Prints(char *s, unsigned char X, unsigned char Y)
{
	LCD5110_SetXY(X,Y);
	while (*s)
 554:	89 91       	ld	r24, Y+
 556:	81 11       	cpse	r24, r1
 558:	fc cf       	rjmp	.-8      	; 0x552 <LCD5110_Prints+0x14>
	{
		LCD5110_Putc(*s);
		s++;
	}
}
 55a:	df 91       	pop	r29
 55c:	cf 91       	pop	r28
 55e:	08 95       	ret

00000560 <HeaderPrints>:
}



void HeaderPrints(char *s)
{
 560:	3f 92       	push	r3
 562:	4f 92       	push	r4
 564:	5f 92       	push	r5
 566:	6f 92       	push	r6
 568:	7f 92       	push	r7
 56a:	8f 92       	push	r8
 56c:	9f 92       	push	r9
 56e:	af 92       	push	r10
 570:	bf 92       	push	r11
 572:	cf 92       	push	r12
 574:	df 92       	push	r13
 576:	ef 92       	push	r14
 578:	ff 92       	push	r15
 57a:	0f 93       	push	r16
 57c:	1f 93       	push	r17
 57e:	cf 93       	push	r28
 580:	df 93       	push	r29
 582:	5c 01       	movw	r10, r24
	unsigned char length = 0;
	unsigned char i, sm;
	
	while (s[length])
 584:	fc 01       	movw	r30, r24
 586:	80 81       	ld	r24, Z
 588:	88 23       	and	r24, r24
 58a:	49 f0       	breq	.+18     	; 0x59e <HeaderPrints+0x3e>
 58c:	10 e0       	ldi	r17, 0x00	; 0
		length++;
 58e:	1f 5f       	subi	r17, 0xFF	; 255
void HeaderPrints(char *s)
{
	unsigned char length = 0;
	unsigned char i, sm;
	
	while (s[length])
 590:	f5 01       	movw	r30, r10
 592:	e1 0f       	add	r30, r17
 594:	f1 1d       	adc	r31, r1
 596:	80 81       	ld	r24, Z
 598:	81 11       	cpse	r24, r1
 59a:	f9 cf       	rjmp	.-14     	; 0x58e <HeaderPrints+0x2e>
 59c:	01 c0       	rjmp	.+2      	; 0x5a0 <HeaderPrints+0x40>



void HeaderPrints(char *s)
{
	unsigned char length = 0;
 59e:	10 e0       	ldi	r17, 0x00	; 0
	unsigned char i, sm;
	
	while (s[length])
		length++;
	
	LCD5110_SetXY(0, 0);
 5a0:	60 e0       	ldi	r22, 0x00	; 0
 5a2:	80 e0       	ldi	r24, 0x00	; 0
 5a4:	99 df       	rcall	.-206    	; 0x4d8 <LCD5110_SetXY>
 5a6:	c8 ea       	ldi	r28, 0xA8	; 168
	for (i = 0; i < 84*2; i++)
		LCD5110_SendByte(0xFF, 1);
 5a8:	61 e0       	ldi	r22, 0x01	; 1
 5aa:	8f ef       	ldi	r24, 0xFF	; 255
 5ac:	46 df       	rcall	.-372    	; 0x43a <LCD5110_SendByte>
 5ae:	c1 50       	subi	r28, 0x01	; 1
	
	while (s[length])
		length++;
	
	LCD5110_SetXY(0, 0);
	for (i = 0; i < 84*2; i++)
 5b0:	d9 f7       	brne	.-10     	; 0x5a8 <HeaderPrints+0x48>
		LCD5110_SendByte(0xFF, 1);
	
	for (unsigned char str = 0; str <= 1; str++)
	{
		LCD5110_SetXY((84-length*6)/2, str);
 5b2:	2a ef       	ldi	r18, 0xFA	; 250
 5b4:	21 03       	mulsu	r18, r17
 5b6:	c0 01       	movw	r24, r0
 5b8:	11 24       	eor	r1, r1
 5ba:	8c 5a       	subi	r24, 0xAC	; 172
 5bc:	9f 4f       	sbci	r25, 0xFF	; 255
 5be:	3c 01       	movw	r6, r24
 5c0:	1a f4       	brpl	.+6      	; 0x5c8 <HeaderPrints+0x68>
 5c2:	ef ef       	ldi	r30, 0xFF	; 255
 5c4:	6e 1a       	sub	r6, r30
 5c6:	7e 0a       	sbc	r7, r30
 5c8:	75 94       	asr	r7
 5ca:	67 94       	ror	r6
 5cc:	d1 2c       	mov	r13, r1
		i = 0;
		while(s[i])
 5ce:	3a 2c       	mov	r3, r10
 5d0:	4b 2c       	mov	r4, r11
 5d2:	51 2c       	mov	r5, r1
		{
			if (s[i] >= 'А')
				
				sm = 97;
			else
				sm = 32;
 5d4:	81 2c       	mov	r8, r1
 5d6:	91 2c       	mov	r9, r1
		i = 0;
		while(s[i])
		{
			if (s[i] >= 'А')
				
				sm = 97;
 5d8:	0f 2e       	mov	r0, r31
 5da:	f1 e6       	ldi	r31, 0x61	; 97
 5dc:	7f 2e       	mov	r7, r31
 5de:	f0 2d       	mov	r31, r0
	for (i = 0; i < 84*2; i++)
		LCD5110_SendByte(0xFF, 1);
	
	for (unsigned char str = 0; str <= 1; str++)
	{
		LCD5110_SetXY((84-length*6)/2, str);
 5e0:	6d 2d       	mov	r22, r13
 5e2:	86 2d       	mov	r24, r6
 5e4:	79 df       	rcall	.-270    	; 0x4d8 <LCD5110_SetXY>
		i = 0;
		while(s[i])
 5e6:	f5 01       	movw	r30, r10
 5e8:	80 81       	ld	r24, Z
 5ea:	88 23       	and	r24, r24
 5ec:	09 f4       	brne	.+2      	; 0x5f0 <HeaderPrints+0x90>
 5ee:	49 c0       	rjmp	.+146    	; 0x682 <HeaderPrints+0x122>
 5f0:	e3 2c       	mov	r14, r3
 5f2:	f4 2c       	mov	r15, r4
 5f4:	c5 2c       	mov	r12, r5
		{
			if (s[i] >= 'А')
 5f6:	80 3c       	cpi	r24, 0xC0	; 192
 5f8:	10 f4       	brcc	.+4      	; 0x5fe <HeaderPrints+0x9e>
				
				sm = 97;
			else
				sm = 32;
 5fa:	00 e2       	ldi	r16, 0x20	; 32
 5fc:	01 c0       	rjmp	.+2      	; 0x600 <HeaderPrints+0xa0>
		i = 0;
		while(s[i])
		{
			if (s[i] >= 'А')
				
				sm = 97;
 5fe:	07 2d       	mov	r16, r7
			else
				sm = 32;
 600:	c8 2d       	mov	r28, r8
 602:	d9 2d       	mov	r29, r9
			
			for (unsigned char j = 0; j < 5; j++)
				if (str)
					LCD5110_SendByte(~(pgm_read_byte(SmallFont[s[i]-sm]+j)>>4), 1); 
				else
					LCD5110_SendByte(~(pgm_read_byte(SmallFont[s[i]-sm]+j)<<4), 1);
 604:	10 e0       	ldi	r17, 0x00	; 0
				sm = 97;
			else
				sm = 32;
			
			for (unsigned char j = 0; j < 5; j++)
				if (str)
 606:	dd 20       	and	r13, r13
 608:	b9 f0       	breq	.+46     	; 0x638 <HeaderPrints+0xd8>
					LCD5110_SendByte(~(pgm_read_byte(SmallFont[s[i]-sm]+j)>>4), 1); 
 60a:	f7 01       	movw	r30, r14
 60c:	80 81       	ld	r24, Z
 60e:	90 e0       	ldi	r25, 0x00	; 0
 610:	80 1b       	sub	r24, r16
 612:	91 0b       	sbc	r25, r17
 614:	fc 01       	movw	r30, r24
 616:	ee 0f       	add	r30, r30
 618:	ff 1f       	adc	r31, r31
 61a:	ee 0f       	add	r30, r30
 61c:	ff 1f       	adc	r31, r31
 61e:	e8 0f       	add	r30, r24
 620:	f9 1f       	adc	r31, r25
 622:	ea 51       	subi	r30, 0x1A	; 26
 624:	ff 4f       	sbci	r31, 0xFF	; 255
 626:	ec 0f       	add	r30, r28
 628:	fd 1f       	adc	r31, r29
 62a:	84 91       	lpm	r24, Z
 62c:	82 95       	swap	r24
 62e:	8f 70       	andi	r24, 0x0F	; 15
 630:	61 e0       	ldi	r22, 0x01	; 1
 632:	80 95       	com	r24
 634:	02 df       	rcall	.-508    	; 0x43a <LCD5110_SendByte>
 636:	16 c0       	rjmp	.+44     	; 0x664 <HeaderPrints+0x104>
				else
					LCD5110_SendByte(~(pgm_read_byte(SmallFont[s[i]-sm]+j)<<4), 1);
 638:	f7 01       	movw	r30, r14
 63a:	80 81       	ld	r24, Z
 63c:	90 e0       	ldi	r25, 0x00	; 0
 63e:	80 1b       	sub	r24, r16
 640:	91 0b       	sbc	r25, r17
 642:	fc 01       	movw	r30, r24
 644:	ee 0f       	add	r30, r30
 646:	ff 1f       	adc	r31, r31
 648:	ee 0f       	add	r30, r30
 64a:	ff 1f       	adc	r31, r31
 64c:	e8 0f       	add	r30, r24
 64e:	f9 1f       	adc	r31, r25
 650:	ea 51       	subi	r30, 0x1A	; 26
 652:	ff 4f       	sbci	r31, 0xFF	; 255
 654:	ec 0f       	add	r30, r28
 656:	fd 1f       	adc	r31, r29
 658:	84 91       	lpm	r24, Z
 65a:	82 95       	swap	r24
 65c:	80 7f       	andi	r24, 0xF0	; 240
 65e:	61 e0       	ldi	r22, 0x01	; 1
 660:	80 95       	com	r24
 662:	eb de       	rcall	.-554    	; 0x43a <LCD5110_SendByte>
 664:	21 96       	adiw	r28, 0x01	; 1
				
				sm = 97;
			else
				sm = 32;
			
			for (unsigned char j = 0; j < 5; j++)
 666:	c5 30       	cpi	r28, 0x05	; 5
 668:	d1 05       	cpc	r29, r1
 66a:	69 f6       	brne	.-102    	; 0x606 <HeaderPrints+0xa6>
				if (str)
					LCD5110_SendByte(~(pgm_read_byte(SmallFont[s[i]-sm]+j)>>4), 1); 
				else
					LCD5110_SendByte(~(pgm_read_byte(SmallFont[s[i]-sm]+j)<<4), 1);
				
			LCD5110_SendByte(0xFF, 1);
 66c:	61 e0       	ldi	r22, 0x01	; 1
 66e:	8f ef       	ldi	r24, 0xFF	; 255
 670:	e4 de       	rcall	.-568    	; 0x43a <LCD5110_SendByte>
			i++;
 672:	c3 94       	inc	r12
	
	for (unsigned char str = 0; str <= 1; str++)
	{
		LCD5110_SetXY((84-length*6)/2, str);
		i = 0;
		while(s[i])
 674:	75 01       	movw	r14, r10
 676:	ec 0c       	add	r14, r12
 678:	f1 1c       	adc	r15, r1
 67a:	f7 01       	movw	r30, r14
 67c:	80 81       	ld	r24, Z
 67e:	81 11       	cpse	r24, r1
 680:	ba cf       	rjmp	.-140    	; 0x5f6 <HeaderPrints+0x96>
	
	LCD5110_SetXY(0, 0);
	for (i = 0; i < 84*2; i++)
		LCD5110_SendByte(0xFF, 1);
	
	for (unsigned char str = 0; str <= 1; str++)
 682:	d3 94       	inc	r13
 684:	f2 e0       	ldi	r31, 0x02	; 2
 686:	df 12       	cpse	r13, r31
 688:	ab cf       	rjmp	.-170    	; 0x5e0 <HeaderPrints+0x80>
			LCD5110_SendByte(0xFF, 1);
			i++;
		}
	}
	
}
 68a:	df 91       	pop	r29
 68c:	cf 91       	pop	r28
 68e:	1f 91       	pop	r17
 690:	0f 91       	pop	r16
 692:	ff 90       	pop	r15
 694:	ef 90       	pop	r14
 696:	df 90       	pop	r13
 698:	cf 90       	pop	r12
 69a:	bf 90       	pop	r11
 69c:	af 90       	pop	r10
 69e:	9f 90       	pop	r9
 6a0:	8f 90       	pop	r8
 6a2:	7f 90       	pop	r7
 6a4:	6f 90       	pop	r6
 6a6:	5f 90       	pop	r5
 6a8:	4f 90       	pop	r4
 6aa:	3f 90       	pop	r3
 6ac:	08 95       	ret

000006ae <LCD5110_LargeNumPrints>:


void LCD5110_LargeNumPrints(char *s, unsigned char X, unsigned char Y)
{
 6ae:	9f 92       	push	r9
 6b0:	af 92       	push	r10
 6b2:	bf 92       	push	r11
 6b4:	cf 92       	push	r12
 6b6:	df 92       	push	r13
 6b8:	ef 92       	push	r14
 6ba:	ff 92       	push	r15
 6bc:	0f 93       	push	r16
 6be:	1f 93       	push	r17
 6c0:	cf 93       	push	r28
 6c2:	df 93       	push	r29
	unsigned char n = 0;
	while (s[n])
 6c4:	fc 01       	movw	r30, r24
 6c6:	20 81       	ld	r18, Z
 6c8:	22 23       	and	r18, r18
 6ca:	c9 f1       	breq	.+114    	; 0x73e <LCD5110_LargeNumPrints+0x90>
 6cc:	b4 2e       	mov	r11, r20
 6ce:	7c 01       	movw	r14, r24
 6d0:	d6 2e       	mov	r13, r22
 6d2:	8c 01       	movw	r16, r24
 6d4:	c1 2c       	mov	r12, r1
	{
		LCD5110_SetXY(X+n*8, Y);
		
		unsigned char c;
		if (s[n] == ' ')
			c = 0;
 6d6:	a1 2c       	mov	r10, r1
		else
			if (s[n] == ':')
				c = 1;
 6d8:	d1 e0       	ldi	r29, 0x01	; 1
				
		for (unsigned char i = 0; i < 16; i++)
		{
			LCD5110_SendByte(pgm_read_byte(LargeNum[c]+i), 1);	
			if (i == 7)
			LCD5110_SetXY(X+n*8, Y+1);	
 6da:	99 24       	eor	r9, r9
 6dc:	93 94       	inc	r9
 6de:	94 0e       	add	r9, r20
void LCD5110_LargeNumPrints(char *s, unsigned char X, unsigned char Y)
{
	unsigned char n = 0;
	while (s[n])
	{
		LCD5110_SetXY(X+n*8, Y);
 6e0:	6b 2d       	mov	r22, r11
 6e2:	8d 2d       	mov	r24, r13
 6e4:	f9 de       	rcall	.-526    	; 0x4d8 <LCD5110_SetXY>
		
		unsigned char c;
		if (s[n] == ' ')
 6e6:	f8 01       	movw	r30, r16
 6e8:	00 81       	ld	r16, Z
 6ea:	00 32       	cpi	r16, 0x20	; 32
 6ec:	21 f0       	breq	.+8      	; 0x6f6 <LCD5110_LargeNumPrints+0x48>
			c = 0;
		else
			if (s[n] == ':')
 6ee:	0a 33       	cpi	r16, 0x3A	; 58
 6f0:	21 f0       	breq	.+8      	; 0x6fa <LCD5110_LargeNumPrints+0x4c>
				c = 1;
			else
				c = s[n]-'0'+2;
 6f2:	0e 52       	subi	r16, 0x2E	; 46
 6f4:	03 c0       	rjmp	.+6      	; 0x6fc <LCD5110_LargeNumPrints+0x4e>
	{
		LCD5110_SetXY(X+n*8, Y);
		
		unsigned char c;
		if (s[n] == ' ')
			c = 0;
 6f6:	0a 2d       	mov	r16, r10
 6f8:	01 c0       	rjmp	.+2      	; 0x6fc <LCD5110_LargeNumPrints+0x4e>
		else
			if (s[n] == ':')
				c = 1;
 6fa:	0d 2f       	mov	r16, r29
 6fc:	f0 e1       	ldi	r31, 0x10	; 16
 6fe:	0f 9f       	mul	r16, r31
 700:	80 01       	movw	r16, r0
 702:	11 24       	eor	r1, r1
 704:	0a 5d       	subi	r16, 0xDA	; 218
 706:	1f 4f       	sbci	r17, 0xFF	; 255
 708:	cd 2f       	mov	r28, r29
 70a:	03 c0       	rjmp	.+6      	; 0x712 <LCD5110_LargeNumPrints+0x64>
 70c:	0f 5f       	subi	r16, 0xFF	; 255
 70e:	1f 4f       	sbci	r17, 0xFF	; 255
 710:	cf 5f       	subi	r28, 0xFF	; 255
			else
				c = s[n]-'0'+2;
				
		for (unsigned char i = 0; i < 16; i++)
		{
			LCD5110_SendByte(pgm_read_byte(LargeNum[c]+i), 1);	
 712:	f8 01       	movw	r30, r16
 714:	84 91       	lpm	r24, Z
 716:	6d 2f       	mov	r22, r29
 718:	90 de       	rcall	.-736    	; 0x43a <LCD5110_SendByte>
			if (i == 7)
 71a:	c8 30       	cpi	r28, 0x08	; 8
 71c:	21 f4       	brne	.+8      	; 0x726 <LCD5110_LargeNumPrints+0x78>
			LCD5110_SetXY(X+n*8, Y+1);	
 71e:	69 2d       	mov	r22, r9
 720:	8d 2d       	mov	r24, r13
 722:	da de       	rcall	.-588    	; 0x4d8 <LCD5110_SetXY>
 724:	f3 cf       	rjmp	.-26     	; 0x70c <LCD5110_LargeNumPrints+0x5e>
			if (s[n] == ':')
				c = 1;
			else
				c = s[n]-'0'+2;
				
		for (unsigned char i = 0; i < 16; i++)
 726:	c0 31       	cpi	r28, 0x10	; 16
 728:	88 f3       	brcs	.-30     	; 0x70c <LCD5110_LargeNumPrints+0x5e>
		{
			LCD5110_SendByte(pgm_read_byte(LargeNum[c]+i), 1);	
			if (i == 7)
			LCD5110_SetXY(X+n*8, Y+1);	
		}
		n++;
 72a:	c3 94       	inc	r12


void LCD5110_LargeNumPrints(char *s, unsigned char X, unsigned char Y)
{
	unsigned char n = 0;
	while (s[n])
 72c:	87 01       	movw	r16, r14
 72e:	0c 0d       	add	r16, r12
 730:	11 1d       	adc	r17, r1
 732:	f8 e0       	ldi	r31, 0x08	; 8
 734:	df 0e       	add	r13, r31
 736:	f8 01       	movw	r30, r16
 738:	80 81       	ld	r24, Z
 73a:	81 11       	cpse	r24, r1
 73c:	d1 cf       	rjmp	.-94     	; 0x6e0 <LCD5110_LargeNumPrints+0x32>
			if (i == 7)
			LCD5110_SetXY(X+n*8, Y+1);	
		}
		n++;
	}
 73e:	df 91       	pop	r29
 740:	cf 91       	pop	r28
 742:	1f 91       	pop	r17
 744:	0f 91       	pop	r16
 746:	ff 90       	pop	r15
 748:	ef 90       	pop	r14
 74a:	df 90       	pop	r13
 74c:	cf 90       	pop	r12
 74e:	bf 90       	pop	r11
 750:	af 90       	pop	r10
 752:	9f 90       	pop	r9
 754:	08 95       	ret

00000756 <ENC_Check>:
//***************************************************************************
// Проверка состояния энкодера
//***************************************************************************
void ENC_Check(void)
{
	if ( (__ENC_PrevState == ((1<<__ENC_E1)|(1<<__ENC_E2))) &&
 756:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <__ENC_PrevState>
 75a:	80 33       	cpi	r24, 0x30	; 48
 75c:	79 f4       	brne	.+30     	; 0x77c <ENC_Check+0x26>
			((__ENC_PIN&((1<<__ENC_E1)|(1<<__ENC_E2)))!=((1<<__ENC_E1)|(1<<__ENC_E2))) )
 75e:	83 b3       	in	r24, 0x13	; 19
 760:	80 73       	andi	r24, 0x30	; 48
//***************************************************************************
// Проверка состояния энкодера
//***************************************************************************
void ENC_Check(void)
{
	if ( (__ENC_PrevState == ((1<<__ENC_E1)|(1<<__ENC_E2))) &&
 762:	80 33       	cpi	r24, 0x30	; 48
 764:	59 f0       	breq	.+22     	; 0x77c <ENC_Check+0x26>
			((__ENC_PIN&((1<<__ENC_E1)|(1<<__ENC_E2)))!=((1<<__ENC_E1)|(1<<__ENC_E2))) )
	{
		if ( (__ENC_PIN & ((1<<__ENC_E1)|(1<<__ENC_E2))) != ((1<<__ENC_E1)|(0<<__ENC_E2)) )
 766:	83 b3       	in	r24, 0x13	; 19
 768:	80 73       	andi	r24, 0x30	; 48
 76a:	80 32       	cpi	r24, 0x20	; 32
 76c:	21 f0       	breq	.+8      	; 0x776 <ENC_Check+0x20>
		{
			SendTask(ENC_Inc);
 76e:	89 ef       	ldi	r24, 0xF9	; 249
 770:	95 e0       	ldi	r25, 0x05	; 5
 772:	62 d0       	rcall	.+196    	; 0x838 <SendTask>
 774:	03 c0       	rjmp	.+6      	; 0x77c <ENC_Check+0x26>
		}
		else
		{
			SendTask(ENC_Dec);
 776:	86 e4       	ldi	r24, 0x46	; 70
 778:	96 e0       	ldi	r25, 0x06	; 6
 77a:	5e d0       	rcall	.+188    	; 0x838 <SendTask>
		}
	}
	__ENC_PrevState = __ENC_PIN & ((1<<__ENC_E1)|(1<<__ENC_E2));
 77c:	83 b3       	in	r24, 0x13	; 19
 77e:	80 73       	andi	r24, 0x30	; 48
 780:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <__ENC_PrevState>

	if (!(__ENC_PIN & (1<<__ENC_But)))										// Если кнопка нажата...
 784:	9b 99       	sbic	0x13, 3	; 19
 786:	0d c0       	rjmp	.+26     	; 0x7a2 <ENC_Check+0x4c>
	{
		if (__ENC_But_CNT != 0)												// ...то если мы не отсчитали задержку длинного нажатия...
 788:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <__ENC_But_CNT>
 78c:	88 23       	and	r24, r24
 78e:	a9 f0       	breq	.+42     	; 0x7ba <ENC_Check+0x64>
		{
			__ENC_But_CNT--;												// ...декрементируем счетчик задержки кнопки.
 790:	81 50       	subi	r24, 0x01	; 1
 792:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <__ENC_But_CNT>
			if (__ENC_But_CNT == 0)											// Если наконец отсчитали нашу задержку...
 796:	81 11       	cpse	r24, r1
 798:	10 c0       	rjmp	.+32     	; 0x7ba <ENC_Check+0x64>
			{
				SendTask(ENC_LongPress);									// ...вызываем обработчик длинного нажатия кнопки.
 79a:	8a eb       	ldi	r24, 0xBA	; 186
 79c:	96 e0       	ldi	r25, 0x06	; 6
 79e:	4c d0       	rcall	.+152    	; 0x838 <SendTask>
 7a0:	0c c0       	rjmp	.+24     	; 0x7ba <ENC_Check+0x64>
			}
		}
	}
	else																	// ...иначе, если кнопка отпущена...
	{
		if ((__ENC_But_CNT != 0) && (__ENC_But_CNT != __ENC_But_Delay))		// ...проверяем, если кнопка была нажата и это было не длинное нажатие...
 7a2:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <__ENC_But_CNT>
 7a6:	88 23       	and	r24, r24
 7a8:	29 f0       	breq	.+10     	; 0x7b4 <ENC_Check+0x5e>
 7aa:	84 36       	cpi	r24, 0x64	; 100
 7ac:	19 f0       	breq	.+6      	; 0x7b4 <ENC_Check+0x5e>
		{
			SendTask(ENC_ShortPress);										// ...вызываем обработчик короткого нажатия кнопки.
 7ae:	81 e9       	ldi	r24, 0x91	; 145
 7b0:	96 e0       	ldi	r25, 0x06	; 6
 7b2:	42 d0       	rcall	.+132    	; 0x838 <SendTask>
		}
		__ENC_But_CNT = __ENC_But_Delay;									// Сбрасываем счетчик задержки длинного нажатия кнопки.
 7b4:	84 e6       	ldi	r24, 0x64	; 100
 7b6:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <__ENC_But_CNT>
	}

	
	SendTimerTask(ENC_Check, __ENC_Time);
 7ba:	65 e0       	ldi	r22, 0x05	; 5
 7bc:	70 e0       	ldi	r23, 0x00	; 0
 7be:	8b ea       	ldi	r24, 0xAB	; 171
 7c0:	93 e0       	ldi	r25, 0x03	; 3
 7c2:	8b d0       	rcall	.+278    	; 0x8da <SendTimerTask>
 7c4:	08 95       	ret

000007c6 <ENC_Init>:
//***************************************************************************
// Инициализация энкодера
//***************************************************************************
void ENC_Init(void)
{
	__ENC_PrevState = ((1<<__ENC_E1)|(1<<__ENC_E2));
 7c6:	80 e3       	ldi	r24, 0x30	; 48
 7c8:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <__ENC_PrevState>
	__ENC_But_CNT = __ENC_But_Delay;
 7cc:	84 e6       	ldi	r24, 0x64	; 100
 7ce:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <__ENC_But_CNT>
	
	__ENC_DDR &= ~((1<<__ENC_E1)|(1<<__ENC_E2)|(1<<__ENC_But));
 7d2:	84 b3       	in	r24, 0x14	; 20
 7d4:	87 7c       	andi	r24, 0xC7	; 199
 7d6:	84 bb       	out	0x14, r24	; 20
	__ENC_PORT |= ((1<<__ENC_E1)|(1<<__ENC_E2)|(1<<__ENC_But));
 7d8:	85 b3       	in	r24, 0x15	; 21
 7da:	88 63       	ori	r24, 0x38	; 56
 7dc:	85 bb       	out	0x15, r24	; 21
	
	SendTask(ENC_Check);
 7de:	8b ea       	ldi	r24, 0xAB	; 171
 7e0:	93 e0       	ldi	r25, 0x03	; 3
 7e2:	2a d0       	rcall	.+84     	; 0x838 <SendTask>
 7e4:	08 95       	ret

000007e6 <Idle>:
		{
			SendTask(__TS_TimerTaskQueue[i].Task);							// ...пхаем эту задачу в диспетчер задач
			__TS_TimerTaskQueue[i].Task = Idle;								// и пишем на ее место затычку.
		}
	}
}
 7e6:	08 95       	ret

000007e8 <RTOS_Init>:
 7e8:	10 92 3a 01 	sts	0x013A, r1	; 0x80013a <__TM_Start>
 7ec:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <__TM_End>
 7f0:	10 92 39 01 	sts	0x0139, r1	; 0x800139 <__TM_TaskCnt>
 7f4:	80 e0       	ldi	r24, 0x00	; 0
 7f6:	90 e0       	ldi	r25, 0x00	; 0
 7f8:	23 ef       	ldi	r18, 0xF3	; 243
 7fa:	33 e0       	ldi	r19, 0x03	; 3
 7fc:	fc 01       	movw	r30, r24
 7fe:	ee 0f       	add	r30, r30
 800:	ff 1f       	adc	r31, r31
 802:	ee 0f       	add	r30, r30
 804:	ff 1f       	adc	r31, r31
 806:	ec 52       	subi	r30, 0x2C	; 44
 808:	ff 4f       	sbci	r31, 0xFF	; 255
 80a:	31 83       	std	Z+1, r19	; 0x01
 80c:	20 83       	st	Z, r18
 80e:	13 82       	std	Z+3, r1	; 0x03
 810:	12 82       	std	Z+2, r1	; 0x02
 812:	01 96       	adiw	r24, 0x01	; 1
 814:	8f 30       	cpi	r24, 0x0F	; 15
 816:	91 05       	cpc	r25, r1
 818:	89 f7       	brne	.-30     	; 0x7fc <RTOS_Init+0x14>
 81a:	08 95       	ret

0000081c <RTOS_Run>:
 81c:	f8 94       	cli
 81e:	83 b7       	in	r24, 0x33	; 51
 820:	8b 7f       	andi	r24, 0xFB	; 251
 822:	83 bf       	out	0x33, r24	; 51
 824:	83 b7       	in	r24, 0x33	; 51
 826:	83 60       	ori	r24, 0x03	; 3
 828:	83 bf       	out	0x33, r24	; 51
 82a:	83 e8       	ldi	r24, 0x83	; 131
 82c:	82 bf       	out	0x32, r24	; 50
 82e:	89 b7       	in	r24, 0x39	; 57
 830:	81 60       	ori	r24, 0x01	; 1
 832:	89 bf       	out	0x39, r24	; 57
 834:	78 94       	sei
 836:	08 95       	ret

00000838 <SendTask>:
 838:	0f b6       	in	r0, 0x3f	; 63
 83a:	07 fe       	sbrs	r0, 7
 83c:	16 c0       	rjmp	.+44     	; 0x86a <SendTask+0x32>
 83e:	f8 94       	cli
 840:	20 91 39 01 	lds	r18, 0x0139	; 0x800139 <__TM_TaskCnt>
 844:	24 31       	cpi	r18, 0x14	; 20
 846:	e0 f0       	brcs	.+56     	; 0x880 <SendTask+0x48>
 848:	0e c0       	rjmp	.+28     	; 0x866 <SendTask+0x2e>
 84a:	91 e0       	ldi	r25, 0x01	; 1
 84c:	01 c0       	rjmp	.+2      	; 0x850 <SendTask+0x18>
 84e:	90 e0       	ldi	r25, 0x00	; 0
 850:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <__TM_End>
 854:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <__TM_TaskCnt>
 858:	8f 5f       	subi	r24, 0xFF	; 255
 85a:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <__TM_TaskCnt>
 85e:	99 23       	and	r25, r25
 860:	d9 f1       	breq	.+118    	; 0x8d8 <SendTask+0xa0>
 862:	78 94       	sei
 864:	08 95       	ret
 866:	78 94       	sei
 868:	08 95       	ret
 86a:	20 91 39 01 	lds	r18, 0x0139	; 0x800139 <__TM_TaskCnt>
 86e:	24 31       	cpi	r18, 0x14	; 20
 870:	00 f1       	brcs	.+64     	; 0x8b2 <SendTask+0x7a>
 872:	08 95       	ret
 874:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <__TM_TaskCnt>
 878:	8f 5f       	subi	r24, 0xFF	; 255
 87a:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <__TM_TaskCnt>
 87e:	f1 cf       	rjmp	.-30     	; 0x862 <SendTask+0x2a>
 880:	e0 91 3d 01 	lds	r30, 0x013D	; 0x80013d <__TM_End>
 884:	f0 e0       	ldi	r31, 0x00	; 0
 886:	ee 0f       	add	r30, r30
 888:	ff 1f       	adc	r31, r31
 88a:	e0 5f       	subi	r30, 0xF0	; 240
 88c:	fe 4f       	sbci	r31, 0xFE	; 254
 88e:	91 83       	std	Z+1, r25	; 0x01
 890:	80 83       	st	Z, r24
 892:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <__TM_End>
 896:	8f 5f       	subi	r24, 0xFF	; 255
 898:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <__TM_End>
 89c:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <__TM_End>
 8a0:	84 31       	cpi	r24, 0x14	; 20
 8a2:	41 f7       	brne	.-48     	; 0x874 <SendTask+0x3c>
 8a4:	d2 cf       	rjmp	.-92     	; 0x84a <SendTask+0x12>
 8a6:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <__TM_TaskCnt>
 8aa:	8f 5f       	subi	r24, 0xFF	; 255
 8ac:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <__TM_TaskCnt>
 8b0:	08 95       	ret
 8b2:	e0 91 3d 01 	lds	r30, 0x013D	; 0x80013d <__TM_End>
 8b6:	f0 e0       	ldi	r31, 0x00	; 0
 8b8:	ee 0f       	add	r30, r30
 8ba:	ff 1f       	adc	r31, r31
 8bc:	e0 5f       	subi	r30, 0xF0	; 240
 8be:	fe 4f       	sbci	r31, 0xFE	; 254
 8c0:	91 83       	std	Z+1, r25	; 0x01
 8c2:	80 83       	st	Z, r24
 8c4:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <__TM_End>
 8c8:	8f 5f       	subi	r24, 0xFF	; 255
 8ca:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <__TM_End>
 8ce:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <__TM_End>
 8d2:	84 31       	cpi	r24, 0x14	; 20
 8d4:	41 f7       	brne	.-48     	; 0x8a6 <SendTask+0x6e>
 8d6:	bb cf       	rjmp	.-138    	; 0x84e <SendTask+0x16>
 8d8:	08 95       	ret

000008da <SendTimerTask>:
 8da:	cf 93       	push	r28
 8dc:	0f b6       	in	r0, 0x3f	; 63
 8de:	07 fe       	sbrs	r0, 7
 8e0:	0c c0       	rjmp	.+24     	; 0x8fa <SendTimerTask+0x20>
 8e2:	f8 94       	cli
 8e4:	c1 e0       	ldi	r28, 0x01	; 1
 8e6:	0a c0       	rjmp	.+20     	; 0x8fc <SendTimerTask+0x22>
 8e8:	2f 5f       	subi	r18, 0xFF	; 255
 8ea:	3f 4f       	sbci	r19, 0xFF	; 255
 8ec:	2f 30       	cpi	r18, 0x0F	; 15
 8ee:	31 05       	cpc	r19, r1
 8f0:	39 f4       	brne	.+14     	; 0x900 <SendTimerTask+0x26>
 8f2:	cc 23       	and	r28, r28
 8f4:	11 f1       	breq	.+68     	; 0x93a <SendTimerTask+0x60>
 8f6:	78 94       	sei
 8f8:	20 c0       	rjmp	.+64     	; 0x93a <SendTimerTask+0x60>
 8fa:	c0 e0       	ldi	r28, 0x00	; 0
 8fc:	20 e0       	ldi	r18, 0x00	; 0
 8fe:	30 e0       	ldi	r19, 0x00	; 0
 900:	d9 01       	movw	r26, r18
 902:	f9 01       	movw	r30, r18
 904:	ee 0f       	add	r30, r30
 906:	ff 1f       	adc	r31, r31
 908:	ee 0f       	add	r30, r30
 90a:	ff 1f       	adc	r31, r31
 90c:	ec 52       	subi	r30, 0x2C	; 44
 90e:	ff 4f       	sbci	r31, 0xFF	; 255
 910:	40 81       	ld	r20, Z
 912:	51 81       	ldd	r21, Z+1	; 0x01
 914:	43 5f       	subi	r20, 0xF3	; 243
 916:	53 40       	sbci	r21, 0x03	; 3
 918:	39 f7       	brne	.-50     	; 0x8e8 <SendTimerTask+0xe>
 91a:	cc 23       	and	r28, r28
 91c:	09 f0       	breq	.+2      	; 0x920 <SendTimerTask+0x46>
 91e:	78 94       	sei
 920:	aa 0f       	add	r26, r26
 922:	bb 1f       	adc	r27, r27
 924:	aa 0f       	add	r26, r26
 926:	bb 1f       	adc	r27, r27
 928:	ac 52       	subi	r26, 0x2C	; 44
 92a:	bf 4f       	sbci	r27, 0xFF	; 255
 92c:	11 96       	adiw	r26, 0x01	; 1
 92e:	9c 93       	st	X, r25
 930:	8e 93       	st	-X, r24
 932:	13 96       	adiw	r26, 0x03	; 3
 934:	7c 93       	st	X, r23
 936:	6e 93       	st	-X, r22
 938:	12 97       	sbiw	r26, 0x02	; 2
 93a:	cf 91       	pop	r28
 93c:	08 95       	ret

0000093e <TaskManager>:
 93e:	f8 94       	cli
 940:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <__TM_TaskCnt>
 944:	88 23       	and	r24, r24
 946:	e1 f0       	breq	.+56     	; 0x980 <TaskManager+0x42>
 948:	e0 91 3a 01 	lds	r30, 0x013A	; 0x80013a <__TM_Start>
 94c:	f0 e0       	ldi	r31, 0x00	; 0
 94e:	ee 0f       	add	r30, r30
 950:	ff 1f       	adc	r31, r31
 952:	e0 5f       	subi	r30, 0xF0	; 240
 954:	fe 4f       	sbci	r31, 0xFE	; 254
 956:	01 90       	ld	r0, Z+
 958:	f0 81       	ld	r31, Z
 95a:	e0 2d       	mov	r30, r0
 95c:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <__TM_Start>
 960:	8f 5f       	subi	r24, 0xFF	; 255
 962:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <__TM_Start>
 966:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <__TM_Start>
 96a:	84 31       	cpi	r24, 0x14	; 20
 96c:	11 f4       	brne	.+4      	; 0x972 <TaskManager+0x34>
 96e:	10 92 3a 01 	sts	0x013A, r1	; 0x80013a <__TM_Start>
 972:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <__TM_TaskCnt>
 976:	81 50       	subi	r24, 0x01	; 1
 978:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <__TM_TaskCnt>
 97c:	78 94       	sei
 97e:	09 95       	icall
 980:	78 94       	sei
 982:	08 95       	ret

00000984 <__vector_9>:

//***************************************************************************
// Прерывание системного таймера
//***************************************************************************
ISR(__TS_ISR)
{
 984:	1f 92       	push	r1
 986:	0f 92       	push	r0
 988:	0f b6       	in	r0, 0x3f	; 63
 98a:	0f 92       	push	r0
 98c:	11 24       	eor	r1, r1
 98e:	ef 92       	push	r14
 990:	ff 92       	push	r15
 992:	0f 93       	push	r16
 994:	1f 93       	push	r17
 996:	2f 93       	push	r18
 998:	3f 93       	push	r19
 99a:	4f 93       	push	r20
 99c:	5f 93       	push	r21
 99e:	6f 93       	push	r22
 9a0:	7f 93       	push	r23
 9a2:	8f 93       	push	r24
 9a4:	9f 93       	push	r25
 9a6:	af 93       	push	r26
 9a8:	bf 93       	push	r27
 9aa:	cf 93       	push	r28
 9ac:	df 93       	push	r29
 9ae:	ef 93       	push	r30
 9b0:	ff 93       	push	r31
	TCNT0 = __TS_Timer0_TCNTDefault;										// Сбрасываем значение счетчика
 9b2:	83 e8       	ldi	r24, 0x83	; 131
 9b4:	82 bf       	out	0x32, r24	; 50
 9b6:	e1 2c       	mov	r14, r1
 9b8:	f1 2c       	mov	r15, r1
			__TS_TimerTaskQueue[i].Time--;									// ...декрементируем ее временную задержку
		}
		else																// ...иначе, если пришло время выполнять задачу...
		{
			SendTask(__TS_TimerTaskQueue[i].Task);							// ...пхаем эту задачу в диспетчер задач
			__TS_TimerTaskQueue[i].Task = Idle;								// и пишем на ее место затычку.
 9ba:	03 ef       	ldi	r16, 0xF3	; 243
 9bc:	13 e0       	ldi	r17, 0x03	; 3
//***************************************************************************
inline void TimerService(void)
{
	for (uint8_t i = 0; i < __TS_TimerQueueSize; i++)						// Прочесываем очередь
	{
		if (__TS_TimerTaskQueue[i].Task == Idle) continue;					// Если натыкаемся на затычку - переходим к следующей ячейке.
 9be:	c7 01       	movw	r24, r14
 9c0:	f7 01       	movw	r30, r14
 9c2:	ee 0f       	add	r30, r30
 9c4:	ff 1f       	adc	r31, r31
 9c6:	ee 0f       	add	r30, r30
 9c8:	ff 1f       	adc	r31, r31
 9ca:	ec 52       	subi	r30, 0x2C	; 44
 9cc:	ff 4f       	sbci	r31, 0xFF	; 255
 9ce:	20 81       	ld	r18, Z
 9d0:	31 81       	ldd	r19, Z+1	; 0x01
 9d2:	23 5f       	subi	r18, 0xF3	; 243
 9d4:	33 40       	sbci	r19, 0x03	; 3
 9d6:	21 f1       	breq	.+72     	; 0xa20 <__vector_9+0x9c>
		if (__TS_TimerTaskQueue[i].Time != 0)								// Если натыкаемся на адекватную задачу и ее время еще не истекло...
 9d8:	f7 01       	movw	r30, r14
 9da:	ee 0f       	add	r30, r30
 9dc:	ff 1f       	adc	r31, r31
 9de:	ee 0f       	add	r30, r30
 9e0:	ff 1f       	adc	r31, r31
 9e2:	ec 52       	subi	r30, 0x2C	; 44
 9e4:	ff 4f       	sbci	r31, 0xFF	; 255
 9e6:	22 81       	ldd	r18, Z+2	; 0x02
 9e8:	33 81       	ldd	r19, Z+3	; 0x03
 9ea:	23 2b       	or	r18, r19
 9ec:	69 f0       	breq	.+26     	; 0xa08 <__vector_9+0x84>
		{
			__TS_TimerTaskQueue[i].Time--;									// ...декрементируем ее временную задержку
 9ee:	88 0f       	add	r24, r24
 9f0:	99 1f       	adc	r25, r25
 9f2:	88 0f       	add	r24, r24
 9f4:	99 1f       	adc	r25, r25
 9f6:	fc 01       	movw	r30, r24
 9f8:	ec 52       	subi	r30, 0x2C	; 44
 9fa:	ff 4f       	sbci	r31, 0xFF	; 255
 9fc:	82 81       	ldd	r24, Z+2	; 0x02
 9fe:	93 81       	ldd	r25, Z+3	; 0x03
 a00:	01 97       	sbiw	r24, 0x01	; 1
 a02:	93 83       	std	Z+3, r25	; 0x03
 a04:	82 83       	std	Z+2, r24	; 0x02
 a06:	0c c0       	rjmp	.+24     	; 0xa20 <__vector_9+0x9c>
		}
		else																// ...иначе, если пришло время выполнять задачу...
		{
			SendTask(__TS_TimerTaskQueue[i].Task);							// ...пхаем эту задачу в диспетчер задач
 a08:	88 0f       	add	r24, r24
 a0a:	99 1f       	adc	r25, r25
 a0c:	88 0f       	add	r24, r24
 a0e:	99 1f       	adc	r25, r25
 a10:	ec 01       	movw	r28, r24
 a12:	cc 52       	subi	r28, 0x2C	; 44
 a14:	df 4f       	sbci	r29, 0xFF	; 255
 a16:	88 81       	ld	r24, Y
 a18:	99 81       	ldd	r25, Y+1	; 0x01
 a1a:	0e df       	rcall	.-484    	; 0x838 <SendTask>
			__TS_TimerTaskQueue[i].Task = Idle;								// и пишем на ее место затычку.
 a1c:	19 83       	std	Y+1, r17	; 0x01
 a1e:	08 83       	st	Y, r16
 a20:	8f ef       	ldi	r24, 0xFF	; 255
 a22:	e8 1a       	sub	r14, r24
 a24:	f8 0a       	sbc	r15, r24
//***************************************************************************
// Запуск таймерной службы
//***************************************************************************
inline void TimerService(void)
{
	for (uint8_t i = 0; i < __TS_TimerQueueSize; i++)						// Прочесываем очередь
 a26:	4f e0       	ldi	r20, 0x0F	; 15
 a28:	e4 16       	cp	r14, r20
 a2a:	f1 04       	cpc	r15, r1
 a2c:	41 f6       	brne	.-112    	; 0x9be <__vector_9+0x3a>
ISR(__TS_ISR)
{
	TCNT0 = __TS_Timer0_TCNTDefault;										// Сбрасываем значение счетчика
	
	TimerService();															// Вызываем таймерную службу
}
 a2e:	ff 91       	pop	r31
 a30:	ef 91       	pop	r30
 a32:	df 91       	pop	r29
 a34:	cf 91       	pop	r28
 a36:	bf 91       	pop	r27
 a38:	af 91       	pop	r26
 a3a:	9f 91       	pop	r25
 a3c:	8f 91       	pop	r24
 a3e:	7f 91       	pop	r23
 a40:	6f 91       	pop	r22
 a42:	5f 91       	pop	r21
 a44:	4f 91       	pop	r20
 a46:	3f 91       	pop	r19
 a48:	2f 91       	pop	r18
 a4a:	1f 91       	pop	r17
 a4c:	0f 91       	pop	r16
 a4e:	ff 90       	pop	r15
 a50:	ef 90       	pop	r14
 a52:	0f 90       	pop	r0
 a54:	0f be       	out	0x3f, r0	; 63
 a56:	0f 90       	pop	r0
 a58:	1f 90       	pop	r1
 a5a:	18 95       	reti

00000a5c <PrintTime>:
			{
				DisplayUpdate();
				on = 0;
			}
		}
		SendTimerTask(MirrorDigit, 500);	
 a5c:	ef 92       	push	r14
 a5e:	ff 92       	push	r15
 a60:	0f 93       	push	r16
 a62:	1f 93       	push	r17
 a64:	cf 93       	push	r28
 a66:	df 93       	push	r29
 a68:	cd b7       	in	r28, 0x3d	; 61
 a6a:	de b7       	in	r29, 0x3e	; 62
 a6c:	29 97       	sbiw	r28, 0x09	; 9
 a6e:	0f b6       	in	r0, 0x3f	; 63
 a70:	f8 94       	cli
 a72:	de bf       	out	0x3e, r29	; 62
 a74:	0f be       	out	0x3f, r0	; 63
 a76:	cd bf       	out	0x3d, r28	; 61
 a78:	0f 2e       	mov	r0, r31
 a7a:	fe e3       	ldi	r31, 0x3E	; 62
 a7c:	ef 2e       	mov	r14, r31
 a7e:	f1 e0       	ldi	r31, 0x01	; 1
 a80:	ff 2e       	mov	r15, r31
 a82:	f0 2d       	mov	r31, r0
 a84:	fe 01       	movw	r30, r28
 a86:	33 96       	adiw	r30, 0x03	; 3
 a88:	be 01       	movw	r22, r28
 a8a:	64 5f       	subi	r22, 0xF4	; 244
 a8c:	7f 4f       	sbci	r23, 0xFF	; 255
 a8e:	0d ec       	ldi	r16, 0xCD	; 205
 a90:	1a e3       	ldi	r17, 0x3A	; 58
 a92:	d7 01       	movw	r26, r14
 a94:	9d 91       	ld	r25, X+
 a96:	7d 01       	movw	r14, r26
 a98:	9f 01       	movw	r18, r30
 a9a:	22 50       	subi	r18, 0x02	; 2
 a9c:	31 09       	sbc	r19, r1
 a9e:	90 9f       	mul	r25, r16
 aa0:	81 2d       	mov	r24, r1
 aa2:	11 24       	eor	r1, r1
 aa4:	86 95       	lsr	r24
 aa6:	86 95       	lsr	r24
 aa8:	86 95       	lsr	r24
 aaa:	40 e3       	ldi	r20, 0x30	; 48
 aac:	48 0f       	add	r20, r24
 aae:	d9 01       	movw	r26, r18
 ab0:	4c 93       	st	X, r20
 ab2:	af 01       	movw	r20, r30
 ab4:	41 50       	subi	r20, 0x01	; 1
 ab6:	51 09       	sbc	r21, r1
 ab8:	88 0f       	add	r24, r24
 aba:	28 2f       	mov	r18, r24
 abc:	22 0f       	add	r18, r18
 abe:	22 0f       	add	r18, r18
 ac0:	82 0f       	add	r24, r18
 ac2:	98 1b       	sub	r25, r24
 ac4:	90 5d       	subi	r25, 0xD0	; 208
 ac6:	da 01       	movw	r26, r20
 ac8:	9c 93       	st	X, r25
 aca:	10 83       	st	Z, r17
 acc:	33 96       	adiw	r30, 0x03	; 3
 ace:	e6 17       	cp	r30, r22
 ad0:	f7 07       	cpc	r31, r23
 ad2:	f9 f6       	brne	.-66     	; 0xa92 <PrintTime+0x36>
 ad4:	19 86       	std	Y+9, r1	; 0x09
 ad6:	43 e0       	ldi	r20, 0x03	; 3
 ad8:	6a e0       	ldi	r22, 0x0A	; 10
 ada:	ce 01       	movw	r24, r28
 adc:	01 96       	adiw	r24, 0x01	; 1
 ade:	e7 dd       	rcall	.-1074   	; 0x6ae <LCD5110_LargeNumPrints>
 ae0:	29 96       	adiw	r28, 0x09	; 9
 ae2:	0f b6       	in	r0, 0x3f	; 63
 ae4:	f8 94       	cli
 ae6:	de bf       	out	0x3e, r29	; 62
 ae8:	0f be       	out	0x3f, r0	; 63
 aea:	cd bf       	out	0x3d, r28	; 61
 aec:	df 91       	pop	r29
 aee:	cf 91       	pop	r28
 af0:	1f 91       	pop	r17
 af2:	0f 91       	pop	r16
 af4:	ff 90       	pop	r15
 af6:	ef 90       	pop	r14
 af8:	08 95       	ret

00000afa <DisplayUpdate>:
 afa:	b4 dc       	rcall	.-1688   	; 0x464 <LCD5110_Clear>
 afc:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <DisplayN>
 b00:	9d ec       	ldi	r25, 0xCD	; 205
 b02:	89 9f       	mul	r24, r25
 b04:	81 2d       	mov	r24, r1
 b06:	11 24       	eor	r1, r1
 b08:	86 95       	lsr	r24
 b0a:	86 95       	lsr	r24
 b0c:	86 95       	lsr	r24
 b0e:	82 30       	cpi	r24, 0x02	; 2
 b10:	b1 f0       	breq	.+44     	; 0xb3e <DisplayUpdate+0x44>
 b12:	28 f4       	brcc	.+10     	; 0xb1e <DisplayUpdate+0x24>
 b14:	88 23       	and	r24, r24
 b16:	49 f0       	breq	.+18     	; 0xb2a <DisplayUpdate+0x30>
 b18:	81 30       	cpi	r24, 0x01	; 1
 b1a:	61 f0       	breq	.+24     	; 0xb34 <DisplayUpdate+0x3a>
 b1c:	08 95       	ret
 b1e:	84 30       	cpi	r24, 0x04	; 4
 b20:	c1 f0       	breq	.+48     	; 0xb52 <DisplayUpdate+0x58>
 b22:	90 f0       	brcs	.+36     	; 0xb48 <DisplayUpdate+0x4e>
 b24:	85 30       	cpi	r24, 0x05	; 5
 b26:	d1 f0       	breq	.+52     	; 0xb5c <DisplayUpdate+0x62>
 b28:	08 95       	ret
 b2a:	80 e6       	ldi	r24, 0x60	; 96
 b2c:	90 e0       	ldi	r25, 0x00	; 0
 b2e:	18 dd       	rcall	.-1488   	; 0x560 <HeaderPrints>
 b30:	95 df       	rcall	.-214    	; 0xa5c <PrintTime>
 b32:	08 95       	ret
 b34:	8b e6       	ldi	r24, 0x6B	; 107
 b36:	90 e0       	ldi	r25, 0x00	; 0
 b38:	13 dd       	rcall	.-1498   	; 0x560 <HeaderPrints>
 b3a:	90 df       	rcall	.-224    	; 0xa5c <PrintTime>
 b3c:	08 95       	ret
 b3e:	86 e7       	ldi	r24, 0x76	; 118
 b40:	90 e0       	ldi	r25, 0x00	; 0
 b42:	0e dd       	rcall	.-1508   	; 0x560 <HeaderPrints>
 b44:	8b df       	rcall	.-234    	; 0xa5c <PrintTime>
 b46:	08 95       	ret
 b48:	81 e8       	ldi	r24, 0x81	; 129
 b4a:	90 e0       	ldi	r25, 0x00	; 0
 b4c:	09 dd       	rcall	.-1518   	; 0x560 <HeaderPrints>
 b4e:	86 df       	rcall	.-244    	; 0xa5c <PrintTime>
 b50:	08 95       	ret
 b52:	8c e8       	ldi	r24, 0x8C	; 140
 b54:	90 e0       	ldi	r25, 0x00	; 0
 b56:	04 dd       	rcall	.-1528   	; 0x560 <HeaderPrints>
 b58:	81 df       	rcall	.-254    	; 0xa5c <PrintTime>
 b5a:	08 95       	ret
 b5c:	87 e9       	ldi	r24, 0x97	; 151
 b5e:	90 e0       	ldi	r25, 0x00	; 0
 b60:	ff dc       	rcall	.-1538   	; 0x560 <HeaderPrints>
 b62:	43 e0       	ldi	r20, 0x03	; 3
 b64:	60 e0       	ldi	r22, 0x00	; 0
 b66:	83 ea       	ldi	r24, 0xA3	; 163
 b68:	90 e0       	ldi	r25, 0x00	; 0
 b6a:	e9 dc       	rcall	.-1582   	; 0x53e <LCD5110_Prints>
 b6c:	44 e0       	ldi	r20, 0x04	; 4
 b6e:	60 e0       	ldi	r22, 0x00	; 0
 b70:	82 eb       	ldi	r24, 0xB2	; 178
 b72:	90 e0       	ldi	r25, 0x00	; 0
 b74:	e4 dc       	rcall	.-1592   	; 0x53e <LCD5110_Prints>
 b76:	45 e0       	ldi	r20, 0x05	; 5
 b78:	60 e0       	ldi	r22, 0x00	; 0
 b7a:	81 ec       	ldi	r24, 0xC1	; 193
 b7c:	90 e0       	ldi	r25, 0x00	; 0
 b7e:	df dc       	rcall	.-1602   	; 0x53e <LCD5110_Prints>
 b80:	08 95       	ret

00000b82 <ReadTime>:
	str[8] = 0;
	LCD5110_LargeNumPrints(str, 10, 3);
}

inline void ReadTime(void)
{
 b82:	ef 92       	push	r14
 b84:	ff 92       	push	r15
 b86:	0f 93       	push	r16
 b88:	1f 93       	push	r17
 b8a:	cf 93       	push	r28
 b8c:	df 93       	push	r29
	for (unsigned char i=0; i<3; i++)
		Time[i] = eeprom_read_byte(&TimeModes[DisplayN/10][i]);
 b8e:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <DisplayN>
 b92:	cd ec       	ldi	r28, 0xCD	; 205
 b94:	8c 9f       	mul	r24, r28
 b96:	c1 2d       	mov	r28, r1
 b98:	11 24       	eor	r1, r1
 b9a:	c6 95       	lsr	r28
 b9c:	c6 95       	lsr	r28
 b9e:	c6 95       	lsr	r28
 ba0:	d0 e0       	ldi	r29, 0x00	; 0
 ba2:	ce 01       	movw	r24, r28
 ba4:	88 0f       	add	r24, r24
 ba6:	99 1f       	adc	r25, r25
 ba8:	c8 0f       	add	r28, r24
 baa:	d9 1f       	adc	r29, r25
 bac:	c0 50       	subi	r28, 0x00	; 0
 bae:	d0 40       	sbci	r29, 0x00	; 0
 bb0:	0e e3       	ldi	r16, 0x3E	; 62
 bb2:	11 e0       	ldi	r17, 0x01	; 1
 bb4:	0f 2e       	mov	r0, r31
 bb6:	f1 e4       	ldi	r31, 0x41	; 65
 bb8:	ef 2e       	mov	r14, r31
 bba:	f1 e0       	ldi	r31, 0x01	; 1
 bbc:	ff 2e       	mov	r15, r31
 bbe:	f0 2d       	mov	r31, r0
 bc0:	ce 01       	movw	r24, r28
 bc2:	f1 d0       	rcall	.+482    	; 0xda6 <eeprom_read_byte>
 bc4:	f8 01       	movw	r30, r16
 bc6:	81 93       	st	Z+, r24
 bc8:	8f 01       	movw	r16, r30
 bca:	21 96       	adiw	r28, 0x01	; 1
	LCD5110_LargeNumPrints(str, 10, 3);
}

inline void ReadTime(void)
{
	for (unsigned char i=0; i<3; i++)
 bcc:	ee 15       	cp	r30, r14
 bce:	ff 05       	cpc	r31, r15
 bd0:	b9 f7       	brne	.-18     	; 0xbc0 <ReadTime+0x3e>
		Time[i] = eeprom_read_byte(&TimeModes[DisplayN/10][i]);
}
 bd2:	df 91       	pop	r29
 bd4:	cf 91       	pop	r28
 bd6:	1f 91       	pop	r17
 bd8:	0f 91       	pop	r16
 bda:	ff 90       	pop	r15
 bdc:	ef 90       	pop	r14
 bde:	08 95       	ret

00000be0 <main>:
void ReadTime(void);


int main(void)
{
	RTOS_Init();
 be0:	03 de       	rcall	.-1018   	; 0x7e8 <RTOS_Init>
	RTOS_Run();
 be2:	1c de       	rcall	.-968    	; 0x81c <RTOS_Run>
	
	ReadTime();
 be4:	ce df       	rcall	.-100    	; 0xb82 <ReadTime>
	
	ENC_Init();
 be6:	ef dd       	rcall	.-1058   	; 0x7c6 <ENC_Init>
	
	LCD5110_Init();
 be8:	4f dc       	rcall	.-1890   	; 0x488 <LCD5110_Init>
	LCD5110_Clear();
 bea:	3c dc       	rcall	.-1928   	; 0x464 <LCD5110_Clear>
	DisplayUpdate();
 bec:	86 df       	rcall	.-244    	; 0xafa <DisplayUpdate>
    while (1)
    {
		TaskManager();
 bee:	a7 de       	rcall	.-690    	; 0x93e <TaskManager>
	}
 bf0:	fe cf       	rjmp	.-4      	; 0xbee <main+0xe>

00000bf2 <ENC_Inc>:

//***************************************************************************
// Энкодер вращается по часовой стрелке
//***************************************************************************
void ENC_Inc(void)
{
 bf2:	ef 92       	push	r14
 bf4:	ff 92       	push	r15
 bf6:	0f 93       	push	r16
 bf8:	1f 93       	push	r17
 bfa:	cf 93       	push	r28
 bfc:	df 93       	push	r29
//Здесь может быть ваш код ;)
	if (DisplayN%10 == 0)
 bfe:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <DisplayN>
 c02:	cd ec       	ldi	r28, 0xCD	; 205
 c04:	8c 9f       	mul	r24, r28
 c06:	c1 2d       	mov	r28, r1
 c08:	11 24       	eor	r1, r1
 c0a:	c6 95       	lsr	r28
 c0c:	c6 95       	lsr	r28
 c0e:	c6 95       	lsr	r28
 c10:	cc 0f       	add	r28, r28
 c12:	9c 2f       	mov	r25, r28
 c14:	99 0f       	add	r25, r25
 c16:	99 0f       	add	r25, r25
 c18:	c9 0f       	add	r28, r25
 c1a:	98 2f       	mov	r25, r24
 c1c:	9c 1b       	sub	r25, r28
 c1e:	c9 2f       	mov	r28, r25
 c20:	59 f5       	brne	.+86     	; 0xc78 <ENC_Inc+0x86>
	{
		if (DisplayN == 50)
 c22:	82 33       	cpi	r24, 0x32	; 50
 c24:	19 f4       	brne	.+6      	; 0xc2c <ENC_Inc+0x3a>
			DisplayN = 0;	
 c26:	10 92 38 01 	sts	0x0138, r1	; 0x800138 <DisplayN>
 c2a:	06 c0       	rjmp	.+12     	; 0xc38 <ENC_Inc+0x46>
		else
			DisplayN += 10;
 c2c:	ca e0       	ldi	r28, 0x0A	; 10
 c2e:	c8 0f       	add	r28, r24
 c30:	c0 93 38 01 	sts	0x0138, r28	; 0x800138 <DisplayN>
		if (DisplayN != 50)
 c34:	c2 33       	cpi	r28, 0x32	; 50
 c36:	01 f1       	breq	.+64     	; 0xc78 <ENC_Inc+0x86>
}

inline void ReadTime(void)
{
	for (unsigned char i=0; i<3; i++)
		Time[i] = eeprom_read_byte(&TimeModes[DisplayN/10][i]);
 c38:	8d ec       	ldi	r24, 0xCD	; 205
 c3a:	c8 9f       	mul	r28, r24
 c3c:	c1 2d       	mov	r28, r1
 c3e:	11 24       	eor	r1, r1
 c40:	c6 95       	lsr	r28
 c42:	c6 95       	lsr	r28
 c44:	c6 95       	lsr	r28
 c46:	d0 e0       	ldi	r29, 0x00	; 0
 c48:	ce 01       	movw	r24, r28
 c4a:	88 0f       	add	r24, r24
 c4c:	99 1f       	adc	r25, r25
 c4e:	c8 0f       	add	r28, r24
 c50:	d9 1f       	adc	r29, r25
 c52:	c0 50       	subi	r28, 0x00	; 0
 c54:	d0 40       	sbci	r29, 0x00	; 0
 c56:	0e e3       	ldi	r16, 0x3E	; 62
 c58:	11 e0       	ldi	r17, 0x01	; 1
 c5a:	0f 2e       	mov	r0, r31
 c5c:	f1 e4       	ldi	r31, 0x41	; 65
 c5e:	ef 2e       	mov	r14, r31
 c60:	f1 e0       	ldi	r31, 0x01	; 1
 c62:	ff 2e       	mov	r15, r31
 c64:	f0 2d       	mov	r31, r0
 c66:	ce 01       	movw	r24, r28
 c68:	9e d0       	rcall	.+316    	; 0xda6 <eeprom_read_byte>
 c6a:	f8 01       	movw	r30, r16
 c6c:	81 93       	st	Z+, r24
 c6e:	8f 01       	movw	r16, r30
 c70:	21 96       	adiw	r28, 0x01	; 1
	LCD5110_LargeNumPrints(str, 10, 3);
}

inline void ReadTime(void)
{
	for (unsigned char i=0; i<3; i++)
 c72:	ee 15       	cp	r30, r14
 c74:	ff 05       	cpc	r31, r15
 c76:	b9 f7       	brne	.-18     	; 0xc66 <ENC_Inc+0x74>
		{
			ReadTime();
		}
	}

	SendTask(DisplayUpdate);
 c78:	8d e7       	ldi	r24, 0x7D	; 125
 c7a:	95 e0       	ldi	r25, 0x05	; 5
 c7c:	dd dd       	rcall	.-1094   	; 0x838 <SendTask>
}
 c7e:	df 91       	pop	r29
 c80:	cf 91       	pop	r28
 c82:	1f 91       	pop	r17
 c84:	0f 91       	pop	r16
 c86:	ff 90       	pop	r15
 c88:	ef 90       	pop	r14
 c8a:	08 95       	ret

00000c8c <ENC_Dec>:

//***************************************************************************
// Энкодер вращается против часовой стрелки
//***************************************************************************
void ENC_Dec(void)
{
 c8c:	ef 92       	push	r14
 c8e:	ff 92       	push	r15
 c90:	0f 93       	push	r16
 c92:	1f 93       	push	r17
 c94:	cf 93       	push	r28
 c96:	df 93       	push	r29
//Здесь может быть ваш код ;)
	if (DisplayN%10 == 0)
 c98:	c0 91 38 01 	lds	r28, 0x0138	; 0x800138 <DisplayN>
 c9c:	8d ec       	ldi	r24, 0xCD	; 205
 c9e:	c8 9f       	mul	r28, r24
 ca0:	81 2d       	mov	r24, r1
 ca2:	11 24       	eor	r1, r1
 ca4:	86 95       	lsr	r24
 ca6:	86 95       	lsr	r24
 ca8:	86 95       	lsr	r24
 caa:	88 0f       	add	r24, r24
 cac:	98 2f       	mov	r25, r24
 cae:	99 0f       	add	r25, r25
 cb0:	99 0f       	add	r25, r25
 cb2:	89 0f       	add	r24, r25
 cb4:	c8 13       	cpse	r28, r24
 cb6:	2b c0       	rjmp	.+86     	; 0xd0e <ENC_Dec+0x82>
	{
		if (DisplayN == 0)
 cb8:	c1 11       	cpse	r28, r1
 cba:	04 c0       	rjmp	.+8      	; 0xcc4 <ENC_Dec+0x38>
			DisplayN = 50;
 cbc:	82 e3       	ldi	r24, 0x32	; 50
 cbe:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <DisplayN>
 cc2:	25 c0       	rjmp	.+74     	; 0xd0e <ENC_Dec+0x82>
		else
			DisplayN -= 10;
 cc4:	ca 50       	subi	r28, 0x0A	; 10
 cc6:	c0 93 38 01 	sts	0x0138, r28	; 0x800138 <DisplayN>
			
		if (DisplayN != 50)
 cca:	c2 33       	cpi	r28, 0x32	; 50
 ccc:	01 f1       	breq	.+64     	; 0xd0e <ENC_Dec+0x82>
}

inline void ReadTime(void)
{
	for (unsigned char i=0; i<3; i++)
		Time[i] = eeprom_read_byte(&TimeModes[DisplayN/10][i]);
 cce:	8d ec       	ldi	r24, 0xCD	; 205
 cd0:	c8 9f       	mul	r28, r24
 cd2:	c1 2d       	mov	r28, r1
 cd4:	11 24       	eor	r1, r1
 cd6:	c6 95       	lsr	r28
 cd8:	c6 95       	lsr	r28
 cda:	c6 95       	lsr	r28
 cdc:	d0 e0       	ldi	r29, 0x00	; 0
 cde:	ce 01       	movw	r24, r28
 ce0:	88 0f       	add	r24, r24
 ce2:	99 1f       	adc	r25, r25
 ce4:	c8 0f       	add	r28, r24
 ce6:	d9 1f       	adc	r29, r25
 ce8:	c0 50       	subi	r28, 0x00	; 0
 cea:	d0 40       	sbci	r29, 0x00	; 0
 cec:	0e e3       	ldi	r16, 0x3E	; 62
 cee:	11 e0       	ldi	r17, 0x01	; 1
 cf0:	0f 2e       	mov	r0, r31
 cf2:	f1 e4       	ldi	r31, 0x41	; 65
 cf4:	ef 2e       	mov	r14, r31
 cf6:	f1 e0       	ldi	r31, 0x01	; 1
 cf8:	ff 2e       	mov	r15, r31
 cfa:	f0 2d       	mov	r31, r0
 cfc:	ce 01       	movw	r24, r28
 cfe:	53 d0       	rcall	.+166    	; 0xda6 <eeprom_read_byte>
 d00:	f8 01       	movw	r30, r16
 d02:	81 93       	st	Z+, r24
 d04:	8f 01       	movw	r16, r30
 d06:	21 96       	adiw	r28, 0x01	; 1
	LCD5110_LargeNumPrints(str, 10, 3);
}

inline void ReadTime(void)
{
	for (unsigned char i=0; i<3; i++)
 d08:	ee 15       	cp	r30, r14
 d0a:	ff 05       	cpc	r31, r15
 d0c:	b9 f7       	brne	.-18     	; 0xcfc <ENC_Dec+0x70>
		{
			ReadTime();
		}
	}

	SendTask(DisplayUpdate);
 d0e:	8d e7       	ldi	r24, 0x7D	; 125
 d10:	95 e0       	ldi	r25, 0x05	; 5
 d12:	92 dd       	rcall	.-1244   	; 0x838 <SendTask>
}
 d14:	df 91       	pop	r29
 d16:	cf 91       	pop	r28
 d18:	1f 91       	pop	r17
 d1a:	0f 91       	pop	r16
 d1c:	ff 90       	pop	r15
 d1e:	ef 90       	pop	r14
 d20:	08 95       	ret

00000d22 <ENC_ShortPress>:
//***************************************************************************
// Короткое нажатие кнопки
//***************************************************************************
void ENC_ShortPress(void)
{
	if (DisplayN%10 == 0)
 d22:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <DisplayN>
 d26:	8d ec       	ldi	r24, 0xCD	; 205
 d28:	98 9f       	mul	r25, r24
 d2a:	81 2d       	mov	r24, r1
 d2c:	11 24       	eor	r1, r1
 d2e:	86 95       	lsr	r24
 d30:	86 95       	lsr	r24
 d32:	86 95       	lsr	r24
 d34:	88 0f       	add	r24, r24
 d36:	28 2f       	mov	r18, r24
 d38:	22 0f       	add	r18, r18
 d3a:	22 0f       	add	r18, r18
 d3c:	82 0f       	add	r24, r18
 d3e:	98 17       	cp	r25, r24
 d40:	c1 f0       	breq	.+48     	; 0xd72 <ENC_ShortPress+0x50>
	{
		// Пуск таймера
	}
	else
	{
		DisplayN++;
 d42:	31 e0       	ldi	r19, 0x01	; 1
 d44:	39 0f       	add	r19, r25
		if (DisplayN%10 == 4)
 d46:	8d ec       	ldi	r24, 0xCD	; 205
 d48:	38 9f       	mul	r19, r24
 d4a:	81 2d       	mov	r24, r1
 d4c:	11 24       	eor	r1, r1
 d4e:	86 95       	lsr	r24
 d50:	86 95       	lsr	r24
 d52:	86 95       	lsr	r24
 d54:	88 0f       	add	r24, r24
 d56:	28 2f       	mov	r18, r24
 d58:	22 0f       	add	r18, r18
 d5a:	22 0f       	add	r18, r18
 d5c:	82 0f       	add	r24, r18
 d5e:	23 2f       	mov	r18, r19
 d60:	28 1b       	sub	r18, r24
 d62:	24 30       	cpi	r18, 0x04	; 4
 d64:	19 f0       	breq	.+6      	; 0xd6c <ENC_ShortPress+0x4a>
	{
		// Пуск таймера
	}
	else
	{
		DisplayN++;
 d66:	30 93 38 01 	sts	0x0138, r19	; 0x800138 <DisplayN>
 d6a:	08 95       	ret
		if (DisplayN%10 == 4)
		{
			DisplayN = DisplayN - 3;
 d6c:	92 50       	subi	r25, 0x02	; 2
 d6e:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <DisplayN>
 d72:	08 95       	ret

00000d74 <ENC_LongPress>:
//***************************************************************************
// Длинное нажатие кнопки
//***************************************************************************
void ENC_LongPress(void)
{
	if (DisplayN%10 == 0)
 d74:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <DisplayN>
 d78:	8d ec       	ldi	r24, 0xCD	; 205
 d7a:	98 9f       	mul	r25, r24
 d7c:	81 2d       	mov	r24, r1
 d7e:	11 24       	eor	r1, r1
 d80:	86 95       	lsr	r24
 d82:	86 95       	lsr	r24
 d84:	86 95       	lsr	r24
 d86:	88 0f       	add	r24, r24
 d88:	28 2f       	mov	r18, r24
 d8a:	22 0f       	add	r18, r18
 d8c:	22 0f       	add	r18, r18
 d8e:	82 0f       	add	r24, r18
 d90:	29 2f       	mov	r18, r25
 d92:	28 1b       	sub	r18, r24
 d94:	21 f4       	brne	.+8      	; 0xd9e <ENC_LongPress+0x2a>
	{
		DisplayN++;
 d96:	9f 5f       	subi	r25, 0xFF	; 255
 d98:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <DisplayN>
 d9c:	08 95       	ret
	}
	else
	{
		DisplayN = DisplayN - DisplayN%10;
 d9e:	92 1b       	sub	r25, r18
 da0:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <DisplayN>
 da4:	08 95       	ret

00000da6 <eeprom_read_byte>:
 da6:	e1 99       	sbic	0x1c, 1	; 28
 da8:	fe cf       	rjmp	.-4      	; 0xda6 <eeprom_read_byte>
 daa:	9f bb       	out	0x1f, r25	; 31
 dac:	8e bb       	out	0x1e, r24	; 30
 dae:	e0 9a       	sbi	0x1c, 0	; 28
 db0:	99 27       	eor	r25, r25
 db2:	8d b3       	in	r24, 0x1d	; 29
 db4:	08 95       	ret

00000db6 <_exit>:
 db6:	f8 94       	cli

00000db8 <__stop_program>:
 db8:	ff cf       	rjmp	.-2      	; 0xdb8 <__stop_program>
